{"file_contents":{"src.mk":{"content":"# **************************************************************************** #\n#                                                                              #\n#                                                         :::      ::::::::    #\n#    src.mk                                             :+:      :+:    :+:    #\n#                                                     +:+ +:+         +:+      #\n#    By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+         #\n#                                                 +#+#+#+#+#+   +#+            #\n#    Created: 2025/08/21 12:39:14 by gkamanur          #+#    #+#              #\n#    Updated: 2025/08/22 15:01:28 by gkamanur         ###   ########.fr        #\n#                                                                              #\n# **************************************************************************** #\n\n# sources.mk: explicit list of all source files\n\nSRC =\t\\\n\t$(wildcard $(LIBFT_DIR)/*.c) \\\n\t$(wildcard $(GET_NEXT_LINE_DIR)/*.c) \\\n\t$(wildcard $(BUILT_DIR)/*.c) \\\n\t$(wildcard $(EXPAN_DIR)/*.c) \\\n\t$(wildcard $(LEXER_DIR)/*.c) \\\n\t$(wildcard $(PIPE_DIR)/*.c) \\\n\t$(wildcard $(PARSE_DIR)/*.c) \\\n\t$(wildcard $(EXEC_DIR)/*.c) \\\n\t$(wildcard $(PROMPT_DIR)/*.c) \\\n\t$(wildcard $(MAIN_DIR)/*.c) \n\nBONUS_SRC =\t$(BONUS_SRC_DIR)/main_bonus.c \\\n\t\t\t$(BONUS_SRC_DIR)/parser_bonus.c \\\n\t\t\t$(BONUS_SRC_DIR)/lexer_bonus.c \\\n\t\t\t$(BONUS_SRC_DIR)/utils_bonus.c \\\n\t\t\t$(BONUS_SRC_DIR)/execute_bonus.c \\\n\t\t\t$(GET_NEXT_LINE_DIR)/get_next_line_bonus.c \\\n\t\t\t$(GET_NEXT_LINE_DIR)/get_next_line_utils_bonus.c\n","size_bytes":1566},"SOURCE/built/array_parser.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   array_parser.c                                     :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/09/04 10:03:00 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/04 10:03:00 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\n/**\n * Checks if a string contains array syntax VAR=(...)\n */\nint\tft_is_array_assignment(const char *arg)\n{\n\tchar\t*equals;\n\tchar\t*open_paren;\n\n\tif (!arg)\n\t\treturn (0);\n\tequals = ft_strchr(arg, '=');\n\tif (!equals)\n\t\treturn (0);\n\topen_paren = ft_strchr(equals + 1, '(');\n\tif (!open_paren)\n\t\treturn (0);\n\t// Check if there's a closing parenthesis\n\tif (!ft_strchr(open_paren, ')'))\n\t\treturn (0);\n\treturn (1);\n}\n\n/**\n * Extracts variable name from array assignment\n */\nchar\t*ft_extract_array_name(const char *arg)\n{\n\tchar\t*equals;\n\n\tif (!arg)\n\t\treturn (NULL);\n\tequals = ft_strchr(arg, '=');\n\tif (!equals)\n\t\treturn (NULL);\n\treturn (ft_substr(arg, 0, equals - arg));\n}\n\n/**\n * Parses array elements from the parentheses content\n */\nstatic char\t**ft_parse_array_elements(const char *content, int *count)\n{\n\tchar\t**elements;\n\tint\t\ti;\n\tint\t\tstart;\n\tint\t\tin_quotes;\n\tint\t\telement_count;\n\tchar\t*current_element;\n\n\tif (!content || !count)\n\t\treturn (NULL);\n\t*count = 0;\n\telements = malloc(sizeof(char *) * 64); // Initial capacity\n\tif (!elements)\n\t\treturn (NULL);\n\ti = 0;\n\telement_count = 0;\n\tin_quotes = 0;\n\tstart = 0;\n\t\n\t// Skip leading whitespace\n\twhile (content[i] && ft_is_space(content[i]))\n\t\ti++;\n\tstart = i;\n\t\n\twhile (content[i])\n\t{\n\t\tif (content[i] == '\"' || content[i] == '\\'')\n\t\t\tin_quotes = !in_quotes;\n\t\telse if (!in_quotes && ft_is_space(content[i]))\n\t\t{\n\t\t\tif (i > start)\n\t\t\t{\n\t\t\t\tcurrent_element = ft_substr(content, start, i - start);\n\t\t\t\tif (current_element)\n\t\t\t\t{\n\t\t\t\t\telements[element_count] = current_element;\n\t\t\t\t\telement_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Skip whitespace\n\t\t\twhile (content[i] && ft_is_space(content[i]))\n\t\t\t\ti++;\n\t\t\tstart = i;\n\t\t\tcontinue;\n\t\t}\n\t\ti++;\n\t}\n\t\n\t// Handle last element\n\tif (i > start)\n\t{\n\t\tcurrent_element = ft_substr(content, start, i - start);\n\t\tif (current_element)\n\t\t{\n\t\t\telements[element_count] = current_element;\n\t\t\telement_count++;\n\t\t}\n\t}\n\t\n\t*count = element_count;\n\treturn (elements);\n}\n\n/**\n * Creates or updates an array variable from assignment\n */\nint\tft_set_array_var(const char *name, const char *value, t_array_var **array_list)\n{\n\tt_array_var\t*existing_array;\n\tt_array_var\t*new_array;\n\tchar\t\t*content;\n\tchar\t\t*open_paren;\n\tchar\t\t*close_paren;\n\tchar\t\t**elements;\n\tint\t\t\telement_count;\n\tint\t\t\ti;\n\n\tif (!name || !value || !array_list)\n\t\treturn (0);\n\t\n\t// Extract content between parentheses\n\topen_paren = ft_strchr(value, '(');\n\tif (!open_paren)\n\t\treturn (0);\n\tclose_paren = ft_strrchr(value, ')');\n\tif (!close_paren || close_paren <= open_paren)\n\t\treturn (0);\n\t\n\tcontent = ft_substr(value, open_paren + 1 - value, close_paren - open_paren - 1);\n\tif (!content)\n\t\treturn (0);\n\t\n\t// Remove existing array if it exists\n\texisting_array = ft_find_array(name, *array_list);\n\tif (existing_array)\n\t{\n\t\tft_remove_array(name, array_list);\n\t}\n\t\n\t// Create new array\n\tnew_array = ft_create_array_node(name);\n\tif (!new_array)\n\t{\n\t\tfree(content);\n\t\treturn (0);\n\t}\n\t\n\t// Parse elements\n\telements = ft_parse_array_elements(content, &element_count);\n\tfree(content);\n\t\n\tif (!elements && element_count > 0)\n\t{\n\t\tft_free_array(new_array);\n\t\treturn (0);\n\t}\n\t\n\t// Add elements to array\n\ti = 0;\n\twhile (i < element_count)\n\t{\n\t\tif (!ft_add_array_element(new_array, elements[i]))\n\t\t{\n\t\t\t// Clean up on failure\n\t\t\twhile (i >= 0)\n\t\t\t{\n\t\t\t\tfree(elements[i]);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tfree(elements);\n\t\t\tft_free_array(new_array);\n\t\t\treturn (0);\n\t\t}\n\t\tfree(elements[i]);\n\t\ti++;\n\t}\n\tfree(elements);\n\t\n\t// Add to array list\n\tnew_array->next_array = *array_list;\n\t*array_list = new_array;\n\t\n\treturn (1);\n}\n\n/**\n * Removes an array from the array list\n */\nvoid\tft_remove_array(const char *name, t_array_var **array_list)\n{\n\tt_array_var\t*current;\n\tt_array_var\t*prev;\n\n\tif (!name || !array_list || !*array_list)\n\t\treturn ;\n\t\n\tcurrent = *array_list;\n\tprev = NULL;\n\t\n\twhile (current)\n\t{\n\t\tif (ft_strcmp(current->array_name, name) == 0)\n\t\t{\n\t\t\tif (prev)\n\t\t\t\tprev->next_array = current->next_array;\n\t\t\telse\n\t\t\t\t*array_list = current->next_array;\n\t\t\tft_free_array(current);\n\t\t\treturn ;\n\t\t}\n\t\tprev = current;\n\t\tcurrent = current->next_array;\n\t}\n}\n","size_bytes":4965},"SOURCE/built/array_utils.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   array_utils.c                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/09/04 10:03:00 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/04 10:03:00 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\n/**\n * Creates a new array variable node\n */\nt_array_var\t*ft_create_array_node(const char *name)\n{\n\tt_array_var\t*new_array;\n\n\tif (!name)\n\t\treturn (NULL);\n\tnew_array = malloc(sizeof(t_array_var));\n\tif (!new_array)\n\t\treturn (NULL);\n\tnew_array->array_name = ft_strdup(name);\n\tif (!new_array->array_name)\n\t{\n\t\tfree(new_array);\n\t\treturn (NULL);\n\t}\n\tnew_array->elements = NULL;\n\tnew_array->element_count = 0;\n\tnew_array->capacity = 0;\n\tnew_array->next_array = NULL;\n\treturn (new_array);\n}\n\n/**\n * Adds an element to an array variable\n */\nint\tft_add_array_element(t_array_var *array, const char *element)\n{\n\tchar\t**new_elements;\n\tint\t\tnew_capacity;\n\tint\t\ti;\n\n\tif (!array || !element)\n\t\treturn (0);\n\tif (array->element_count >= array->capacity)\n\t{\n\t\tnew_capacity = array->capacity == 0 ? 4 : array->capacity * 2;\n\t\tnew_elements = malloc(sizeof(char *) * new_capacity);\n\t\tif (!new_elements)\n\t\t\treturn (0);\n\t\ti = 0;\n\t\twhile (i < array->element_count)\n\t\t{\n\t\t\tnew_elements[i] = array->elements[i];\n\t\t\ti++;\n\t\t}\n\t\tfree(array->elements);\n\t\tarray->elements = new_elements;\n\t\tarray->capacity = new_capacity;\n\t}\n\tarray->elements[array->element_count] = ft_strdup(element);\n\tif (!array->elements[array->element_count])\n\t\treturn (0);\n\tarray->element_count++;\n\treturn (1);\n}\n\n/**\n * Finds an array variable by name\n */\nt_array_var\t*ft_find_array(const char *name, t_array_var *array_list)\n{\n\tt_array_var\t*current;\n\n\tif (!name)\n\t\treturn (NULL);\n\tcurrent = array_list;\n\twhile (current)\n\t{\n\t\tif (ft_strcmp(current->array_name, name) == 0)\n\t\t\treturn (current);\n\t\tcurrent = current->next_array;\n\t}\n\treturn (NULL);\n}\n\n/**\n * Gets the first element of an array (for simple variable access)\n */\nchar\t*ft_get_array_first_element(const char *name, t_array_var *array_list)\n{\n\tt_array_var\t*array;\n\n\tarray = ft_find_array(name, array_list);\n\tif (!array || array->element_count == 0)\n\t\treturn (NULL);\n\treturn (array->elements[0]);\n}\n\n/**\n * Frees an array variable and all its elements\n */\nvoid\tft_free_array(t_array_var *array)\n{\n\tint\ti;\n\n\tif (!array)\n\t\treturn ;\n\tfree(array->array_name);\n\ti = 0;\n\twhile (i < array->element_count)\n\t{\n\t\tfree(array->elements[i]);\n\t\ti++;\n\t}\n\tfree(array->elements);\n\tfree(array);\n}\n\n/**\n * Frees the entire array list\n */\nvoid\tft_free_array_list(t_array_var **array_list)\n{\n\tt_array_var\t*current;\n\tt_array_var\t*next;\n\n\tif (!array_list)\n\t\treturn ;\n\tcurrent = *array_list;\n\twhile (current)\n\t{\n\t\tnext = current->next_array;\n\t\tft_free_array(current);\n\t\tcurrent = next;\n\t}\n\t*array_list = NULL;\n}\n","size_bytes":3415},"SOURCE/built/built.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   built.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/12 08:04:25 by robello           #+#    #+#             */\n/*   Updated: 2025/08/28 14:56:01 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tis_builtin_argv(char **av_cmd)\n{\n\tif (!av_cmd || !av_cmd[0])\n\t\treturn (0);\n\treturn (!ft_strcmp(av_cmd[0], \"echo\") || !ft_strcmp(av_cmd[0], \"cd\")\n\t\t|| !ft_strcmp(av_cmd[0], \"pwd\") || !ft_strcmp(av_cmd[0], \"export\")\n\t\t|| !ft_strcmp(av_cmd[0], \"unset\") || !ft_strcmp(av_cmd[0], \"env\")\n\t\t|| !ft_strcmp(av_cmd[0], \"exit\"));\n}\n\nint\tft_dispatch_builtin(char **av_cmd, t_env_var **env_list, t_shell *shell)\n{\n\tif (!av_cmd || !av_cmd[0])\n\t\treturn (shell->last_status);\n\tif (!ft_strcmp(av_cmd[0], \"echo\"))\n\t\treturn (builtin_echo(av_cmd, env_list));\n\telse if (!ft_strcmp(av_cmd[0], \"cd\"))\n\t\treturn (builtin_cd(av_cmd, env_list));\n\telse if (!ft_strcmp(av_cmd[0], \"pwd\"))\n\t\treturn (builtin_pwd(av_cmd, env_list));\n\telse if (!ft_strcmp(av_cmd[0], \"export\"))\n\t\treturn (builtin_export(av_cmd, env_list, NULL, NULL));\n\telse if (!ft_strcmp(av_cmd[0], \"unset\"))\n\t\treturn (builtin_unset(av_cmd, env_list));\n\telse if (!ft_strcmp(av_cmd[0], \"env\"))\n\t\treturn (builtin_env(av_cmd, env_list));\n\telse if (!ft_strcmp(av_cmd[0], \"exit\"))\n\t\treturn (builtin_exit(av_cmd, shell));\n\treturn (shell->last_status);\n}\n","size_bytes":2013},"SOURCE/built/built_array_wrapper.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   built_array_wrapper.c                              :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/09/04 10:03:00 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/04 10:03:00 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\n/**\n * Enhanced builtin dispatcher that handles array variables\n * This wraps the existing export functionality to support arrays\n */\nint\tft_dispatch_builtin_with_arrays(char **av_cmd, t_env_var **env_list, t_shell *shell)\n{\n\tint\t\ti;\n\tint\t\thas_array_syntax;\n\n\tif (!av_cmd || !av_cmd[0])\n\t\treturn (shell->last_status);\n\t\n\t// For export command, check if we have array syntax\n\tif (!ft_strcmp(av_cmd[0], \"export\"))\n\t{\n\t\thas_array_syntax = 0;\n\t\ti = 1;\n\t\twhile (av_cmd[i])\n\t\t{\n\t\t\tif (ft_is_array_assignment(av_cmd[i]))\n\t\t\t{\n\t\t\t\thas_array_syntax = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tif (has_array_syntax)\n\t\t{\n\t\t\t// Use array-aware export\n\t\t\treturn (ft_builtin_export_with_arrays(av_cmd, env_list, &shell->array_list));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use original export for regular variables\n\t\t\treturn (builtin_export(av_cmd, env_list, NULL, NULL));\n\t\t}\n\t}\n\t\n\t// For all other commands, use the original dispatcher\n\treturn (ft_dispatch_builtin(av_cmd, env_list, shell));\n}\n\n/**\n * Enhanced variable expansion that checks both env and array lists\n * This can be used in the expansion phase\n */\nchar\t*ft_get_expanded_variable_value(const char *name, t_shell *shell)\n{\n\tchar\t*env_value;\n\tchar\t*array_value;\n\n\tif (!name || !shell)\n\t\treturn (NULL);\n\t\n\t// First check regular environment variables\n\tenv_value = get_env_value((char *)name, shell->env_list);\n\tif (env_value)\n\t\treturn (ft_strdup(env_value));\n\t\n\t// Then check array variables (return first element)\n\tarray_value = ft_get_array_first_element(name, shell->array_list);\n\tif (array_value)\n\t\treturn (ft_strdup(array_value));\n\t\n\treturn (NULL);\n}\n\n/**\n * Initialize shell with array support\n */\nvoid\tft_init_shell_arrays(t_shell *shell)\n{\n\tif (shell)\n\t\tshell->array_list = NULL;\n}\n\n/**\n * Clean up shell arrays\n */\nvoid\tft_clean_shell_arrays(t_shell *shell)\n{\n\tif (shell && shell->array_list)\n\t\tft_free_array_list(&shell->array_list);\n}\n","size_bytes":2799},"SOURCE/built/cd.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   cd.c                                               :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:25:09 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/15 10:35:31 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nstatic int\tft_cd_arg_has_ws(char *path)\n{\n\tint\ti;\n\n\tif (!path)\n\t\treturn (0);\n\ti = 0;\n\twhile (path[i])\n\t{\n\t\tif (path[i] == ' ' || path[i] == '\\t' || path[i] == '\\n')\n\t\t{\n\t\t\tft_putstr_fd(\"cd: too many arguments\\n\", 2);\n\t\t\treturn (1);\n\t\t}\n\t\ti++;\n\t}\n\treturn (0);\n}\n\nchar\t*ft_get_cd(char **av_cmd, t_env_var **env_list)\n{\n\tchar\t*path;\n\n\tif (!av_cmd[1])\n\t{\n\t\tpath = get_env_value(\"HOME\", *env_list);\n\t\tif (!path)\n\t\t{\n\t\t\tft_putstr_fd(\"cd: HOME not set\\n\", 2);\n\t\t\treturn (NULL);\n\t\t}\n\t\treturn (path);\n\t}\n\tif (av_cmd[2])\n\t\treturn (ft_putstr_fd(\"cd: too many arguments\\n\", 2), NULL);\n\tpath = av_cmd[1];\n\tif (!ft_strcmp(path, \"-\"))\n\t{\n\t\tpath = get_env_value(\"OLDPWD\", *env_list);\n\t\tif (!path)\n\t\t\treturn (ft_putstr_fd(\"cd: OLDPWD not set\\n\", 2), NULL);\n\t\tft_putstr_fd(path, 1);\n\t}\n\tif (ft_cd_arg_has_ws(path))\n\t\treturn (NULL);\n\treturn (path);\n}\n\nint\tbuiltin_cd(char **av_cmd, t_env_var **env_list)\n{\n\tchar\t*old_pwd;\n\tchar\t*new_pwd;\n\tchar\t*path;\n\n\tpath = ft_get_cd(av_cmd, env_list);\n\tif (!path)\n\t\treturn (1);\n\told_pwd = getcwd(NULL, 0);\n\tif (!old_pwd)\n\t\treturn (perror(\"cd: getcwd\"), 1);\n\tif (chdir(path) != 0)\n\t\treturn (perror(\"cd\"), free(old_pwd), 1);\n\tnew_pwd = getcwd(NULL, 0);\n\tif (!new_pwd)\n\t\treturn (perror(\"cd: getcwd\"), free(old_pwd), 1);\n\tif (!ft_set_env_var(\"OLDPWD\", old_pwd, env_list)\n\t\t|| !ft_set_env_var(\"PWD\", new_pwd, env_list))\n\t{\n\t\tfree(old_pwd);\n\t\tfree(new_pwd);\n\t\treturn (1);\n\t}\n\tfree(old_pwd);\n\tfree(new_pwd);\n\treturn (0);\n}\n","size_bytes":2361},"SOURCE/built/echo.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   echo.c                                             :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:23:23 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/25 13:40:58 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tbuiltin_echo(char **av_cmd, t_env_var **env_list)\n{\n\tint\tnewline;\n\tint\ti;\n\n\t(void)env_list;\n\tnewline = 1;\n\ti = 1;\n\tif (av_cmd[1] && !ft_strcmp(av_cmd[1], \"-n\"))\n\t{\n\t\tnewline = 0;\n\t\ti = 2;\n\t}\n\twhile (av_cmd[i])\n\t{\n\t\tft_putstr_fd(av_cmd[i], 1);\n\t\tif (av_cmd[i + 1])\n\t\t\tft_putchar_fd(' ', 1);\n\t\ti++;\n\t}\n\tif (newline)\n\t\tft_putchar_fd('\\n', 1);\n\treturn (0);\n}\n\n// int\tcell_echo(char **args)\n// {\n// \tint start = 1;\n// \tbool newline = true;\n\n// \tif (!args || !args[0])\n// \t\treturn (1);\n\n// \t// Check for the -n option\n// \tif (args[1] && !strcmp(args[1], \"-n\"))\n// \t{\n// \t\tnewline = false;\n// \t\tstart = 2;\n// \t}\n\n// \t// Print each argument separated by a space\n// \tfor (int i = start; args[i]; i++)\n// \t{\n// \t\tp(\"%s\", args[i]);\n// \t\tif (args[i + 1])\n// \t\t\tp(\" \");\n// \t}\n\n// \t// Print newline if -n option is not present\n// \tif (newline)\n// \t\tp(\"\\n\");\n\n// \treturn (0);\n// }","size_bytes":1796},"SOURCE/built/env.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   env.c                                              :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:28:22 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/20 14:25:11 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tbuiltin_env(char **av_cmd, t_env_var **env_list)\n{\n\tt_env_var\t*current;\n\n\tif (av_cmd[1])\n\t{\n\t\tft_putstr_fd(\"env: too many arguments\\n\", 2);\n\t\treturn (1);\n\t}\n\tcurrent = *env_list;\n\twhile (current)\n\t{\n\t\tif (current->envar_name && current->envar_value)\n\t\t{\n\t\t\tft_putstr_fd(current->envar_name, 1);\n\t\t\tft_putchar_fd('=', 1);\n\t\t\tft_putstr_fd(current->envar_value, 1);\n\t\t\tft_putchar_fd('\\n', 1);\n\t\t}\n\t\tcurrent = current->next_envar;\n\t}\n\treturn (0);\n}\n","size_bytes":1376},"SOURCE/built/env_var.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   env_var.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:22:33 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/20 14:25:11 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nchar\t*get_env_value(char *name, t_env_var *env_list)\n{\n\tt_env_var\t*tmp;\n\tsize_t\t\tname_len;\n\n\ttmp = env_list;\n\tname_len = ft_strlen(name);\n\twhile (tmp)\n\t{\n\t\tif (ft_strncmp(tmp->envar_name, name, name_len) == 0\n\t\t\t&& tmp->envar_name[name_len] == '\\0')\n\t\t\treturn (tmp->envar_value);\n\t\ttmp = tmp->next_envar;\n\t}\n\treturn (NULL);\n}\n\nint\tft_update_env_var(t_env_var *current, const char *value)\n{\n\tfree(current->envar_value);\n\tif (value)\n\t\tcurrent->envar_value = ft_strdup(value);\n\telse\n\t\tcurrent->envar_value = ft_strdup(\"\");\n\tif (!current->envar_value)\n\t\treturn (0);\n\treturn (1);\n}\n\nint\tft_create_env_var(const char *name, const char *value, t_env_var **env_list)\n{\n\tt_env_var\t*new_node;\n\n\tnew_node = malloc(sizeof(t_env_var));\n\tif (!new_node)\n\t\treturn (0);\n\tnew_node->envar_name = ft_strdup(name);\n\tif (value)\n\t\tnew_node->envar_value = ft_strdup(value);\n\telse\n\t\tnew_node->envar_value = ft_strdup(\"\");\n\tif (!new_node->envar_name || !new_node->envar_value)\n\t{\n\t\tfree(new_node->envar_name);\n\t\tfree(new_node->envar_value);\n\t\tfree(new_node);\n\t\treturn (0);\n\t}\n\tnew_node->next_envar = *env_list;\n\t*env_list = new_node;\n\treturn (1);\n}\n\nint\tft_set_env_var(const char *name, const char *value, t_env_var **env_list)\n{\n\tt_env_var\t*current;\n\n\tif (!name || !env_list)\n\t\treturn (0);\n\tcurrent = *env_list;\n\twhile (current)\n\t{\n\t\tif (!ft_strcmp(current->envar_name, name))\n\t\t\treturn (ft_update_env_var(current, value));\n\t\tcurrent = current->next_envar;\n\t}\n\treturn (ft_create_env_var(name, value, env_list));\n}\n\nvoid\tunset_env_variable(const char *name, t_env_var **env_list)\n{\n\tt_env_var\t*current;\n\tt_env_var\t*prev;\n\n\tif (!name || !env_list || !*env_list)\n\t\treturn ;\n\tcurrent = *env_list;\n\tprev = NULL;\n\twhile (current)\n\t{\n\t\tif (!ft_strcmp(current->envar_name, name))\n\t\t{\n\t\t\tif (prev)\n\t\t\t\tprev->next_envar = current->next_envar;\n\t\t\telse\n\t\t\t\t*env_list = current->next_envar;\n\t\t\tfree(current->envar_name);\n\t\t\tfree(current->envar_value);\n\t\t\tfree(current);\n\t\t\treturn ;\n\t\t}\n\t\tprev = current;\n\t\tcurrent = current->next_envar;\n\t}\n}\n","size_bytes":2931},"SOURCE/built/exit.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   exit.c                                             :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:29:12 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/15 10:36:54 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tis_numeric(const char *str)\n{\n\tint\ti;\n\n\tif (!str || !*str)\n\t\treturn (0);\n\ti = 0;\n\tif (str[0] == '+' || str[0] == '-')\n\t\ti++;\n\twhile (str[i])\n\t{\n\t\tif (!ft_isdigit(str[i]))\n\t\t\treturn (0);\n\t\ti++;\n\t}\n\treturn (1);\n}\n\nint\tbuiltin_exit(char **av_cmd, t_shell *shell)\n{\n\tlong\texit_code;\n\n\t//printf(RED \"\\n✅ EXIT ✅\\n\" RESET);\n\tif (av_cmd[1])\n\t{\n\t\tif (!is_numeric(av_cmd[1]))\n\t\t{\n\t\t\tft_putstr_fd(\"exit: numeric argument required\\n\", 2);\n\t\t\texit_code = 2;\n\t\t}\n\t\telse if (av_cmd[2])\n\t\t{\n\t\t\tft_putstr_fd(\"exit: too many arguments\\n\", 2);\n\t\t\treturn (1);\n\t\t}\n\t\telse\n\t\t\texit_code = ft_atoi(av_cmd[1]);\n\t}\n\telse\n\t\texit_code = shell->last_status;\n\tft_putstr_fd(RED \"exit\\n\" RESET, 1);\n\texit(exit_code);\n}\n","size_bytes":1622},"SOURCE/built/export.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   export.c                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:26:40 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/28 15:53:23 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nstatic char *strip_single_paren(const char *s)\n{\n\tsize_t len;\n\n\tif (!s)\n\t\treturn (NULL);\n\tlen = ft_strlen(s);\n\t// optional surrounding spaces are already handled elsewhere; keep it simple here\n\tif (len >= 2 && s[0] == '(' && s[len - 1] == ')')\n\t\treturn (ft_substr(s, 1, len - 2));\n\treturn (ft_strdup(s));\n}\n\nstatic void\tinit_export_state(t_export_state *state)\n{\n\tstate->last_name = NULL;\n\tstate->last_was_assignment = 0;\n\tstate->status = 0;\n}\n\nstatic void\thandle_invalid_arg(char *arg, t_export_state *state,\n\t\tt_env_var **env_list)\n{\n\tchar\t*old_val;\n\tchar\t*tmp;\n\tchar\t*joined;\n\n\tif (state->last_was_assignment && state->last_name && !ft_strchr(arg, '='))\n\t{\n\t\told_val = get_env_value(state->last_name, *env_list);\n\t\ttmp = ft_strjoin(old_val ? old_val : \"\", \" \");\n\t\tjoined = ft_strjoin(tmp, arg);\n\t\tfree(tmp);\n\t\tft_set_env_var(state->last_name, joined, env_list);\n\t\tfree(joined);\n\t}\n\telse\n\t{\n\t\tprint_export_error(arg);\n\t\tstate->status = 1;\n\t\tg_gb.last_sig = 1;\n\t}\n\tif (state->last_name)\n\t{\n\t\tfree(state->last_name);\n\t\tstate->last_name = NULL;\n\t}\n\tstate->last_was_assignment = 0;\n}\n\nstatic void\tprocess_assignment(char *arg, char *equals, t_export_state *state,\n\t\tt_env_var **env_list)\n{\n\tchar\t*name;\n\tchar\t*value;\n\n\tname = ft_substr(arg, 0, equals - arg);\n\t{\n\t\tchar *raw = ft_strdup(equals + 1);\n\t\tchar *normalized = strip_single_paren(raw);\n\t\tfree(raw);\n\t\tvalue = normalized;\n\t}\n\tft_set_env_var(name, value, env_list);\n\tif (state->last_name)\n\t\tfree(state->last_name);\n\tstate->last_name = ft_strdup(name);\n\tstate->last_was_assignment = 1;\n\tfree(name);\n\tfree(value);\n}\n\nstatic void\tprocess_non_assignment(char *arg, t_export_state *state,\n\t\tt_env_var **env_list)\n{\n\tif (!get_env_value(arg, *env_list))\n\t\tft_set_env_var(arg, \"\", env_list);\n\tif (state->last_name)\n\t{\n\t\tfree(state->last_name);\n\t\tstate->last_name = NULL;\n\t}\n\tstate->last_was_assignment = 0;\n}\n\n\nint\tbuiltin_export(char **av_cmd, t_env_var **env_list, char *arg, char *equals)\n{\n\tt_export_state\tstate;\n\tint\t\t\t\ti;\n\n\ti = 1;\n\tinit_export_state(&state);\n\tif (!av_cmd[1])\n\t{\n\t\tprint_export_list(*env_list);\n\t\treturn (0);\n\t}\n\twhile (av_cmd && av_cmd[i])\n\t{\n\t\targ = av_cmd[i];\n\t\tequals = ft_strchr(arg, '=');\n\t\tif (!is_valid_export_arg(arg))\n\t\t\thandle_invalid_arg(arg, &state, env_list);\n\t\telse if (equals)\n\t\t\tprocess_assignment(arg, equals, &state, env_list);\n\t\telse\n\t\t\tprocess_non_assignment(arg, &state, env_list);\n\t\ti++;\n\t}\n\tif (state.last_name)\n\t\tfree(state.last_name);\n\treturn (state.status);\n}\n","size_bytes":3383},"SOURCE/built/export_arrays.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   export_arrays.c                                    :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/09/04 10:03:00 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/04 10:03:00 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\n/**\n * Gets variable value from either env_list or array_list\n */\nchar\t*ft_get_variable_value(const char *name, t_env_var *env_list, t_array_var *array_list)\n{\n\tchar\t*env_value;\n\tchar\t*array_value;\n\n\tif (!name)\n\t\treturn (NULL);\n\t\n\t// First check regular environment variables\n\tenv_value = get_env_value((char *)name, env_list);\n\tif (env_value)\n\t\treturn (env_value);\n\t\n\t// Then check array variables (return first element)\n\tarray_value = ft_get_array_first_element(name, array_list);\n\treturn (array_value);\n}\n\n/**\n * Enhanced builtin_export that handles both regular and array variables\n */\nint\tft_builtin_export_with_arrays(char **av_cmd, t_env_var **env_list, t_array_var **array_list)\n{\n\tint\t\ti;\n\tchar\t*arg;\n\tchar\t*equals;\n\tchar\t*name;\n\n\tif (!av_cmd[1])\n\t{\n\t\tprint_export_list(*env_list);\n\t\treturn (0);\n\t}\n\t\n\ti = 1;\n\twhile (av_cmd && av_cmd[i])\n\t{\n\t\targ = av_cmd[i];\n\t\tequals = ft_strchr(arg, '=');\n\t\t\n\t\tif (!is_valid_export_arg(arg))\n\t\t{\n\t\t\tprint_export_error(arg);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (equals)\n\t\t{\n\t\t\tname = ft_substr(arg, 0, equals - arg);\n\t\t\tif (!name)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Check if it's an array assignment\n\t\t\tif (ft_is_array_assignment(arg))\n\t\t\t{\n\t\t\t\t// Remove from regular env vars if it exists\n\t\t\t\tunset_env_variable(name, env_list);\n\t\t\t\t// Set as array variable\n\t\t\t\tft_set_array_var(name, equals + 1, array_list);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Remove from arrays if it exists\n\t\t\t\tft_remove_array(name, array_list);\n\t\t\t\t// Set as regular variable\n\t\t\t\tft_set_env_var(name, equals + 1, env_list);\n\t\t\t}\n\t\t\tfree(name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Variable without assignment - create empty if doesn't exist\n\t\t\tif (!get_env_value(arg, *env_list) && !ft_find_array(arg, *array_list))\n\t\t\t\tft_set_env_var(arg, \"\", env_list);\n\t\t}\n\t\t\n\t\ti++;\n\t}\n\t\n\treturn (0);\n}\n","size_bytes":2711},"SOURCE/built/export_utils.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   export_utils.c                                     :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/28 11:23:39 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/15 10:37:50 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nsize_t\tft_export_name_len(const char *arg)\n{\n    size_t\ti;\n\n    if (!arg)\n        return (0);\n    i = 0;\n    while (arg[i] && arg[i] != '=')\n        i++;\n    return (i);\n}\n\nint\tis_valid_export_arg(const char *arg)\n{\n    size_t\tname_len;\n    size_t\ti;\n\n    if (!arg || !arg[0])\n        return (0);\n    name_len = ft_export_name_len(arg);\n    if (name_len == 0)\n        return (0);\n    if (!(ft_isalpha(arg[0]) || arg[0] == '_'))\n        return (0);\n    i = 1;\n    while (i < name_len)\n    {\n        if (!(ft_isalnum(arg[i]) || arg[i] == '_'))\n            return (0);\n        i++;\n    }\n    return (1);\n}\n\nvoid\tprint_export_error(const char *name)\n{\n    ft_putstr_fd(\"minishell: export: `\", 2);\n    ft_putstr_fd(name, 2);\n    ft_putendl_fd(\"': not a valid identifier\", 2);\n}\n\nvoid\tprint_export_list(t_env_var *env_list)\n{\n\twhile (env_list)\n\t{\n\t\tif (env_list->envar_name)\n\t\t{\n\t\t\tft_putstr_fd(\"declare -x \", 1);\n\t\t\tft_putstr_fd(env_list->envar_name, 1);\n\t\t\tif (env_list->envar_value)\n\t\t\t{\n\t\t\t\tft_putstr_fd(\"=\\\"\", 1);\n\t\t\t\tft_putstr_fd(env_list->envar_value, 1);\n\t\t\t\tft_putchar_fd('\"', 1);\n\t\t\t}\n\t\t\tft_putchar_fd('\\n', 1);\n\t\t}\n\t\tenv_list = env_list->next_envar;\n\t}\n}\n\n","size_bytes":2088},"SOURCE/built/pwd.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   pwd.c                                              :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:25:57 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/20 14:25:11 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tbuiltin_pwd(char **av_cmd, t_env_var **env_list)\n{\n\tchar\tcurrent_wdir[PATH_MAX];\n\n\t(void)av_cmd;\n\t(void)env_list;\n\tif (getcwd(current_wdir, sizeof(current_wdir)) != NULL)\n\t{\n\t\tft_putstr_fd(current_wdir, 1);\n\t\tft_putchar_fd('\\n', 1);\n\t\treturn (0);\n\t}\n\tperror(\"pwd\");\n\treturn (1);\n}\n","size_bytes":1212},"SOURCE/built/unset.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   unset.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:27:38 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/15 10:38:32 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tis_valid_unset_identifier(const char *str)\n{\n\tint\ti;\n\n\tif (!str || !str[0])\n\t\treturn (0);\n\tif (!ft_isalpha(str[0]) && str[0] != '_')\n\t\treturn (0);\n\ti = 1;\n\twhile (str[i])\n\t{\n\t\tif (!ft_isalnum(str[i]) && str[i] != '_')\n\t\t\treturn (0);\n\t\ti++;\n\t}\n\treturn (1);\n}\n\nint\tbuiltin_unset(char **av_cmd, t_env_var **env_list)\n{\n\tint\tstatus;\n\tint\ti;\n\n\tif (!av_cmd[1])\n\t\treturn (0);\n\tstatus = 0;\n\ti = 1;\n\twhile (av_cmd[i])\n\t{\n\t\tif (is_valid_unset_identifier(av_cmd[i]))\n\t\t\tunset_env_variable(av_cmd[i], env_list);\n\t\telse\n\t\t{\n\t\t\tft_putstr_fd(\"unset: `\", 1);\n\t\t\tft_putstr_fd(av_cmd[i], 1);\n\t\t\tft_putstr_fd(\"': not a valid identifier\\n\", 1);\n\t\t\tstatus = 1;\n\t\t}\n\t\ti++;\n\t}\n\treturn (status);\n}\n","size_bytes":1605},"SOURCE/execute/command.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   command.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:55:50 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/15 11:57:14 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\n// Add to SOURCE/execute/command.c\n// Add to SOURCE/execute/command.c\nvoid\tft_put_syntax_error(const char *token)\n{\n\tft_putstr_fd(\"minishell: syntax error near unexpected token `\", 2);\n\tft_putstr_fd(token, 2);\n\tft_putstr_fd(\"'\\n\", 2);\n}\n\nvoid\tft_put_bash_error(const char *command, const char *error)\n{\n\tft_putstr_fd(\"minishell: \", 2);\n\tft_putstr_fd(command, 2);\n\tft_putstr_fd(\": \", 2);\n\tft_putstr_fd(error, 2);\n\tft_putstr_fd(\"\\n\", 2);\n}\n\nvoid\tft_put_bash_error_with_arg(const char *command, const char *arg, const char *error)\n{\n\tft_putstr_fd(\"minishell: \", 2);\n\tft_putstr_fd(command, 2);\n\tft_putstr_fd(\": `\", 2);\n\tft_putstr_fd(arg, 2);\n\tft_putstr_fd(\"': \", 2);\n\tft_putstr_fd(error, 2);\n\tft_putstr_fd(\"\\n\", 2);\n}\n\n// void\texec_command(t_comnd *current, char **envp)\n// {\n// \tchar\t*fullpath;\n\n// \tif (current->av_cmd && current->av_cmd[0])\n// \t{\n// \t\tfullpath = ft_get_cmd_path(current->av_cmd[0], envp);\n// \t\tif (!fullpath)\n// \t\t{\n// \t\t\tft_putstr_fd(\"minishell: \", 2);\n// \t\t\tft_putstr_fd(current->av_cmd[0], 2);\n// \t\t\tft_putstr_fd(\": command not found\\n\", 2);\n// \t\t\texit(127); // Command not found\n// \t\t}\n// \t\t// printf(\"print :%s \\n\",fullpath);\n// \t\t// for (int i = 0; current->av_cmd[i]; i++)\n//     \t// \tfprintf(stderr, \"argv[%d] = [%s]\\n\", i, current->av_cmd[i]);\n// \t\texecve(fullpath, current->av_cmd, envp);\n// \t\tft_putstr_fd(\"minishell: \", 2);\n// \t\tft_putstr_fd(current->av_cmd[0], 2);\n// \t\tft_putstr_fd(\": \", 2);\n// \t\tft_putstr_fd(strerror(errno), 2);\n// \t\tft_putstr_fd(\"\\n\", 2);\n// \t\tfree(fullpath);\n// \t\texit(126); // Permission denied/execve failure\n// \t}\n// \texit(127); // No command\n// }\nvoid exec_command(t_comnd *current, char **envp)\n{\n    char *fullpath;\n\n    if (!current || !current->av_cmd || !current->av_cmd[0])\n        exit(127); // No command\n\n    // Find full path\n    fullpath = ft_get_cmd_path(current->av_cmd[0], envp);\n    if (!fullpath)\n    {\n        // Command not found\n        ft_putstr_fd(\"minishell: \", 2);\n        ft_putstr_fd(current->av_cmd[0], 2);\n        ft_putstr_fd(\": command not found\\n\", 2);\n        exit(127);\n    }\n\n    // Execute the command\n    execve(fullpath, current->av_cmd, envp);\n\n    // If execve returns, it failed\n    perror(current->av_cmd[0]); // prints exactly one error, e.g. \"cat: minishell.h: No such file or directory\"\n    free(fullpath);\n    exit(126); // execve failed\n}\n\nvoid\tfork_and_exec(t_comnd *curre, int prev_fd, int pipe_fd[2], char **envp)\n{\n\tpid_t\tpid;\n\n\tpid = fork();\n\tft_check_fork(pid);\n\tif (pid == 0)\n\t{\n\t\tif (pipe_fd != NULL)\n\t\t{\n\t\t\tclose(pipe_fd[0]);\n\t\t\tft_child_setup(curre, prev_fd, pipe_fd[1]);\n\t\t}\n\t\telse\n\t\t\tft_child_setup(curre, prev_fd, -1);\n\t\texec_command(curre, envp);\n\t}\n}\n\nvoid\tft_parent_cleanup(int *prev_fd, int pipe_fd[2])\n{\n\tif (*prev_fd != -1)\n\t{\n\t\tclose(*prev_fd);\n\t\t*prev_fd = -1;\n\t}\n\tif (pipe_fd && pipe_fd[1] != -1)\n\t{\n\t\tclose(pipe_fd[1]);\n\t\tpipe_fd[1] = -1;\n\t}\n}\n\n// #ifdef DEBUG\nvoid\tprint_commands(t_comnd *cmds)\n{\n\tint\ti;\n\tint\tj;\n\n\ti = 0;\n\twhile (cmds)\n\t{\n\t\tprintf(\"Command %d:\\n\", i);\n\t\tif (cmds->av_cmd)\n\t\t{\n\t\t\tj = 0;\n\t\t\twhile (cmds->av_cmd[j])\n\t\t\t{\n\t\t\t\tprintf(\"  argv[%d]: %s\\n\", j, cmds->av_cmd[j]);\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif (cmds->infile_name)\n\t\t\tprintf(\"  infile: %s\\n\", cmds->infile_name);\n\t\tif (cmds->outfile_name)\n\t\t\tprintf(\"  outfile: %s\\n\", cmds->outfile_name);\n\t\tif (cmds->delimiter)\n\t\t\tprintf(\"  heredoc delimiter: %s\\n\", cmds->delimiter);\n\t\tcmds = cmds->next;\n\t\ti++;\n\t}\n}\n// #endif\n","size_bytes":4328},"SOURCE/execute/env_array.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   env_array.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:31:53 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/20 14:25:11 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nvoid\tfree_env_array(char **envp)\n{\n\tint\ti;\n\n\ti = 0;\n\tif (!envp)\n\t\treturn ;\n\twhile (envp[i])\n\t{\n\t\tfree(envp[i]);\n\t\ti++;\n\t}\n\tfree(envp);\n}\n\nvoid\tft_trim_newline(char *str)\n{\n\tsize_t\tlen;\n\n\tlen = ft_strlen(str);\n\twhile (len > 0 && (str[len - 1] == '\\n' || str[len - 1] == ' '\n\t\t\t|| str[len - 1] == '\\t'))\n\t{\n\t\tstr[len - 1] = '\\0';\n\t\tlen--;\n\t}\n}\n\nint\tfree_partial_envp(char **envp, int i)\n{\n\twhile (i > 0)\n\t\tfree(envp[--i]);\n\treturn (0);\n}\n\nint\tfill_envp_array(char **envp, t_env_var *env_list)\n{\n\tchar\t*tmp_str;\n\tint\t\ti;\n\n\ti = 0;\n\twhile (env_list)\n\t{\n\t\ttmp_str = ft_strjoin(env_list->envar_name, \"=\");\n\t\tif (!tmp_str)\n\t\t\treturn (free_partial_envp(envp, i));\n\t\tenvp[i] = ft_strjoin(tmp_str, env_list->envar_value);\n\t\tfree(tmp_str);\n\t\tif (!envp[i])\n\t\t\treturn (free_partial_envp(envp, i));\n\t\ti++;\n\t\tenv_list = env_list->next_envar;\n\t}\n\tenvp[i] = NULL;\n\treturn (1);\n}\n\nchar\t**ft_env_list_to_array(t_env_var *env_list)\n{\n\tt_env_var\t*tmp;\n\tchar\t\t**envp;\n\tint\t\t\tcount;\n\n\tcount = 0;\n\ttmp = env_list;\n\twhile (tmp)\n\t{\n\t\tcount++;\n\t\ttmp = tmp->next_envar;\n\t}\n\tenvp = malloc(sizeof(char *) * (count + 1));\n\tif (!envp)\n\t\treturn (NULL);\n\tif (!fill_envp_array(envp, env_list))\n\t{\n\t\tfree(envp);\n\t\treturn (NULL);\n\t}\n\treturn (envp);\n}\n","size_bytes":2140},"SOURCE/execute/execute.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   execute.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:59:45 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/02 16:35:20 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tcount_cmds(t_comnd *cmd)\n{\n\tint\tcount;\n\n\tcount = 0;\n\twhile (cmd)\n\t{\n\t\tcount++;\n\t\tcmd = cmd->next;\n\t}\n\treturn (count);\n}\n\nint\tis_parent_builtin(t_comnd *cmd)\n{\n\tif (!cmd->next && is_builtin_argv(cmd->av_cmd))\n\t\tif (!ft_strcmp(cmd->av_cmd[0], \"cd\") || !ft_strcmp(cmd->av_cmd[0],\n\t\t\t\t\"export\") || !ft_strcmp(cmd->av_cmd[0], \"unset\")\n\t\t\t|| !ft_strcmp(cmd->av_cmd[0], \"exit\"))\n\t\t\treturn (1);\n\treturn (0);\n}\n\n// void\trun_child(t_pipe *ctx)\n// {\n// \tredirect_input(ctx->cmd, ctx->prev);\n// \tredirect_output(ctx->cmd, ctx->pfd);\n// \tif (ctx->pfd[0] >= 0)\n// \t\tclose(ctx->pfd[0]);\n// \tif (ctx->pfd[1] >= 0)\n// \t\tclose(ctx->pfd[1]);\n// \tif (ctx->prev >= 0)\n// \t\tclose(ctx->prev);\n// \tif (is_builtin_argv(ctx->cmd->av_cmd))\n// \t{\n// \t\texit(ft_dispatch_builtin(ctx->cmd->av_cmd, &ctx->shell->env_list,\n// \t\t\t\tctx->shell));\n// \t}\n// \texec_command(ctx->cmd, ctx->envp);\n// \texit(1);\n// }\n\n\n\n\nvoid run_child(t_pipe *ctx)\n{\n    t_comnd *cmd = ctx->cmd;\n\n    // Apply input/output redirections\n\tif (cmd->outfile == -2) // Redirection failed\n    {\n        exit(1); // Exit with error code 1\n    }\n    redirect_input(cmd, ctx->prev, ctx->i == 0);\n    redirect_output(cmd, ctx->pfd);\n\n    // Close unused pipe ends\n    if (ctx->pfd[0] >= 0) close(ctx->pfd[0]);\n    if (ctx->pfd[1] >= 0) close(ctx->pfd[1]);\n    if (ctx->prev >= 0) close(ctx->prev);\n\n    // Check if it's a builtin\n    if (is_builtin_argv(cmd->av_cmd))\n    {\n        exit(ft_dispatch_builtin_with_arrays(cmd->av_cmd, &ctx->shell->env_list, ctx->shell));\n    }\n\n    // Execute external command\n    exec_command(cmd, ctx->envp);\n\n    // If exec_command fails, exit to avoid child continuing\n    exit(1);\n}\n\n\nvoid\tft_wait_all(pid_t *pids, int count, t_shell *shell)\n{\n\tint\ti;\n\tint\tstatus;\n\tint last_status;\n\n\ti = 0;\n\tlast_status = 0;\n\twhile (i < count)\n\t{\n\t\twaitpid(pids[i], &status, 0);\n\t\tif (i == count - 1)\n\t\t{\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tlast_status = WEXITSTATUS(status);\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tlast_status = 128 + WTERMSIG(status);\n\t\t}\n\t\ti++;\n\t}\n\tshell->last_status = last_status;\n}\n","size_bytes":2979},"SOURCE/execute/execve_cmd.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   execve_cmd.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:39:45 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/20 14:25:11 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nvoid\tft_execve_cmd_flat(char **av_cmd, t_env_var *env_list)\n{\n\tchar\t**envp;\n\n\tenvp = ft_env_list_to_array(env_list);\n\tif (!envp)\n\t\texit(EXIT_FAILURE);\n\tft_execve_cmd(av_cmd, envp);\n\tfree_env_array(envp);\n}\n\nvoid\tft_execve_shell_cmd(char *cmd_str, char **env)\n{\n\tchar\t*argv[4];\n\n\targv[0] = \"/bin/sh\";\n\targv[1] = \"-c\";\n\targv[2] = cmd_str;\n\targv[3] = NULL;\n\texecve(argv[0], argv, env);\n\tft_putstr_fd(\"minishell: line 1: \", 2);\n\tft_putstr_fd(cmd_str, 2);\n\tft_putstr_fd(\": \", 2);\n\tft_putstr_fd(strerror(errno), 2);\n\tft_putstr_fd(\"\\n\", 2);\n\tget_next_line(-1);\n\texit(EXIT_FAILURE);\n}\n\nvoid\tft_execve_cmd(char **av_cmd, char **env)\n{\n\tchar\t*command_line;\n\tint\t\ti;\n\n\tif (!av_cmd || !av_cmd[0])\n\t{\n\t\tft_putstr_fd(\"minishell: command not found: (empty)\\n\", 2);\n\t\tget_next_line(-1);\n\t\texit(127);\n\t}\n\ti = 0;\n\twhile (av_cmd[i])\n\t{\n\t\tif (ft_strchr(av_cmd[i], '\\'') || ft_strchr(av_cmd[i], '\"')\n\t\t\t|| ft_strchr(av_cmd[i], '\\\\') || ft_strchr(av_cmd[i], '$')\n\t\t\t|| ft_strchr(av_cmd[i], '*') || ft_strchr(av_cmd[i], '`'))\n\t\t{\n\t\t\tcommand_line = ft_join_arguments(av_cmd);\n\t\t\tft_execve_shell_cmd(command_line, env);\n\t\t\tfree(command_line);\n\t\t\treturn ;\n\t\t}\n\t\ti++;\n\t}\n\tft_execve_normal_cmd_array(av_cmd, env);\n}\n","size_bytes":2115},"SOURCE/execute/fd_utils.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   fd_utils.c                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:40:56 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/21 12:01:19 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\n\n\n\nvoid\tredirect_input(t_comnd *c, int prev, int is_first_cmd)\n{\n\tif (c->infile >= 0)\n\t{\n\t\tdup2(c->infile, 0);\n\t\tclose(c->infile);\n\t}\n\telse if (prev >= 0)\n\t\tdup2(prev, 0);\n\telse if (!is_first_cmd)\n\t{\n\t\t// Only redirect to /dev/null if not the first command in pipeline\n\t\tint devnull = open(\"/dev/null\", O_RDONLY);\n\t\tif (devnull >= 0)\n\t\t{\n\t\t\tdup2(devnull, 0);\n\t\t\tclose(devnull);\n\t\t}\n\t}\n\t// If is_first_cmd is true and no prev/infile, preserve original stdin\n\t// This allows commands like 'cat' in 'cat | cat | ls' to wait for input\n}\n\nvoid\tredirect_output(t_comnd *c, int *pfd)\n{\n\tif (c->outfile >= 0)\n\t{\n\t\tdup2(c->outfile, 1);\n\t\tclose(c->outfile);\n\t}\n\telse if (pfd[1] >= 0)\n\t\tdup2(pfd[1], 1);\n}\n\nvoid\tcleanup_all_fds(t_comnd *cmds)\n{\n\tt_comnd\t*current;\n\n\tcurrent = cmds;\n\twhile (current)\n\t{\n\t\tcleanup_command_fds(current);\n\t\tcurrent = current->next;\n\t}\n}\n\nvoid\tcleanup_command_fds(t_comnd *cmd)\n{\n\tif (cmd->infile != -1)\n\t{\n\t\tclose(cmd->infile);\n\t\tcmd->infile = -1;\n\t}\n\tif (cmd->outfile != -1)\n\t{\n\t\tclose(cmd->outfile);\n\t\tcmd->outfile = -1;\n\t}\n}\n\nvoid\tft_put_exec_error(char *cmd, char **cmd_array, char *fullpath)\n{\n\tft_putstr_fd(\"minishell: line 1: \", 2);\n\tft_putstr_fd(cmd, 2);\n\tft_putstr_fd(\": \", 2);\n\tft_putstr_fd(strerror(errno), 2);\n\tft_putstr_fd(\"\\n\", 2);\n\tfree(fullpath);\n\tft_free_strings(cmd_array);\n\texit(EXIT_FAILURE);\n}\n","size_bytes":2260},"SOURCE/execute/file_utils.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   file_utils.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/21 12:05:59 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/21 12:06:38 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tft_open_file(char *filename, int mode, int permis)\n{\n\tif (mode == O_RDONLY)\n\t\treturn (open(filename, mode));\n\telse\n\t\treturn (open(filename, mode, permis));\n}\n\nint\tft_open_outfile(char *filename, int here_flag)\n{\n\tint\tflags;\n\tint\tfd;\n\n\tflags = O_WRONLY | O_CREAT;\n\tif (here_flag)\n\t\tflags |= O_APPEND;\n\telse\n\t\tflags |= O_TRUNC;\n\tfd = open(filename, flags, 0644);\n\tif (fd < 0)\n\t\tperror(\"open file\");\n\treturn (fd);\n}\n","size_bytes":1344},"SOURCE/execute/files_child.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   files_child.c                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:42:43 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/21 12:22:59 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nvoid\tft_child_proxs(int infile, int out_fd, t_comnd *cmd, t_shell *shell)\n{\n\tif (infile >= 0)\n\t\tdup2(infile, STDIN_FILENO);\n\tdup2(out_fd, STDOUT_FILENO);\n\tif (infile >= 0)\n\t\tclose(infile);\n\tif (out_fd >= 0)\n\t\tclose(out_fd);\n\tft_execve_cmd_flat(cmd->av_cmd, shell->env_list);\n\texit(EXIT_FAILURE);\n}\n\nvoid\tft_frk_chld(t_comnd *cmd, int pipe_fd[2], int prev_infi, t_shell *shell)\n{\n\tpid_t\tchild;\n\n\tif (pipe(pipe_fd) < 0)\n\t\tft_error_exit(\"pipe\");\n\tchild = fork();\n\tft_check_fork(child);\n\tif (child == 0)\n\t{\n\t\tclose(pipe_fd[0]);\n\t\tif (prev_infi >= 0)\n\t\t{\n\t\t\tdup2(prev_infi, STDIN_FILENO);\n\t\t\tclose(prev_infi);\n\t\t}\n\t\tdup2(pipe_fd[1], STDOUT_FILENO);\n\t\tclose(pipe_fd[1]);\n\t\topen_infile(cmd, 1);\n\t\topen_outfile(cmd, 0, cmd->infile);\n\t\tft_execve_cmd_flat(cmd->av_cmd, shell->env_list);\n\t\tcleanup_command_fds(cmd);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (prev_infi >= 0)\n\t\tclose(prev_infi);\n\tclose(pipe_fd[1]);\n}\n","size_bytes":1820},"SOURCE/execute/get_cmd_path.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   get_cmd_path.c                                     :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:38:22 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/21 12:02:23 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nvoid\tft_put_cmd_not_found(char *cmd, char **cmd_array)\n{\n\tft_putstr_fd(\"minishell: \", 2);\n\tft_putstr_fd(cmd, 2);\n\tft_putstr_fd(\": command not found\\n\", 2);\n\tif (cmd_array)\n\t\tft_free_strings(cmd_array);\n\tget_next_line(-1);\n\texit(127);\n}\n\nchar\t*ft_create_path(char *cmd, char **dirs)\n{\n\tchar\tfullpath[PATH_MAX];\n\tint\t\ti;\n\n\ti = 0;\n\twhile (dirs[i])\n\t{\n\t\tft_strlcpy(fullpath, dirs[i], sizeof(fullpath));\n\t\tft_strlcat(fullpath, \"/\", sizeof(fullpath));\n\t\tft_strlcat(fullpath, cmd, sizeof(fullpath));\n\t\tif (access(fullpath, X_OK) == 0)\n\t\t\treturn (ft_strdup(fullpath));\n\t\ti++;\n\t}\n\treturn (NULL);\n}\n\nchar\t*ft_get_path_env(char *var, char **env)\n{\n\tsize_t\tlen;\n\tint\t\ti;\n\n\tif (!var || !env)\n\t\treturn (NULL);\n\tlen = ft_strlen(var);\n\ti = 0;\n\twhile (env[i])\n\t{\n\t\tif (ft_strncmp(env[i], var, len) == 0 && env[i][len] == '=')\n\t\t\treturn (env[i] + len + 1);\n\t\ti++;\n\t}\n\treturn (NULL);\n}\n\nchar\t*ft_get_cmd_path(char *cmd, char **env)\n{\n\tchar\t**dirs;\n\tchar\t*path_env;\n\tchar\t*path_copy;\n\tchar\t*fullpath;\n\n\tif (!cmd || cmd[0] == '\\0')\n\t\treturn (NULL);\n\tif (access(cmd, X_OK) == 0)\n\t\treturn (ft_strdup(cmd));\n\tpath_env = ft_get_path_env(\"PATH\", env);\n\tif (!path_env)\n\t\treturn (NULL);\n\tpath_copy = ft_strdup(path_env);\n\tif (!path_copy)\n\t\treturn (NULL);\n\tdirs = ft_split(path_copy, ':');\n\tfree(path_copy);\n\tif (!dirs)\n\t\treturn (NULL);\n\tfullpath = ft_create_path(cmd, dirs);\n\tft_free_strings(dirs);\n\treturn (fullpath);\n}\n\nvoid\tft_execve_normal_cmd_array(char **cmd_array, char **env)\n{\n\tchar\t*fullpath;\n\tint\t\ti;\n\n\tif (!cmd_array || !cmd_array[0])\n\t\tft_put_cmd_not_found(\"(null)\", cmd_array);\n\ti = 0;\n\twhile (cmd_array[i])\n\t\tft_trim_newline(cmd_array[i++]);\n\tfullpath = ft_get_cmd_path(cmd_array[0], env);\n\tif (!fullpath)\n\t\tft_put_cmd_not_found(cmd_array[0], cmd_array);\n\texecve(fullpath, cmd_array, env);\n\tft_put_exec_error(cmd_array[0], cmd_array, fullpath);\n}\n\n// void\tft_execve_normal_cmd_array(char **cmd_array, char **env)\n// {\n// \tchar\t*fullpath;\n// \tint\t\ti;\n\n// \tif (!cmd_array || !cmd_array[0])\n// \t\tft_put_cmd_not_found(\"(null)\", cmd_array);\n// \ti = 0;\n// \twhile (cmd_array[i])\n// \t\tft_trim_newline(cmd_array[i++]);\n// \tfullpath = ft_get_cmd_path(cmd_array[0], env);\n// \tif (!fullpath)\n// \t\tft_put_cmd_not_found(cmd_array[0], cmd_array);\n// \tprintf(\"Exec path: %s\\n\", fullpath); // Delete when ready\n// \ti = 0;\n// \twhile (cmd_array[i]) // Delete when ready\n// \t{\n// \t\tprintf(\"Arg[%d]: %s\\n\", i, cmd_array[i]);\n// \t\ti++;\n// \t}\n// \texecve(fullpath, cmd_array, env);\n// \tft_put_exec_error(cmd_array[0], cmd_array, fullpath);\n// }\n","size_bytes":3435},"SOURCE/execute/grep.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   grep.c                                             :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/09/02 15:52:43 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/15 10:40:42 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nstatic int\tis_grep(const char *fullpath)\n{\n\tconst char *basename;\n\n\tif (!fullpath)\n\t\treturn (0);\n\tbasename = ft_strrchr(fullpath, '/');\n\tif (basename)\n\t\tbasename++;  // Skip the '/'\n\telse\n\t\tbasename = fullpath;\n\tif (ft_strcmp(basename, \"grep\") == 0)\n\t\treturn (1);\n\treturn (0);\n}\n\nstatic char\t*join_args(char **args, const char *separator)\n{\n\tchar\t*joined;\n\t//char\t*temp;\n\tsize_t\ttotal_len;\n\tint\t\ti;\n\n\tif (!args || !args[0])\n\t\treturn (NULL);\n\ttotal_len = 0;\n\ti = 0;\n\twhile (args[i])\n\t{\n\t\ttotal_len += ft_strlen(args[i]);\n\t\tif (args[i + 1])\n\t\t\ttotal_len += ft_strlen(separator);\n\t\ti++;\n\t}\n\tjoined = ft_calloc(total_len + 1, sizeof(char));\n\tif (!joined)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (args[i])\n\t{\n\t\tft_strlcat(joined, args[i], total_len + 1);\n\t\tif (args[i + 1])\n\t\t\tft_strlcat(joined, separator, total_len + 1);\n\t\ti++;\n\t}\n\treturn (joined);\n}\n\nvoid\texecve_grep_handler(const char *fullpath, t_comnd *current, char **envp)\n{\n\tchar\t*joined;\n\tchar\t*new_argv[3];\n\t// if (fullpath && current->av_cmd && ft_strcmp(current->av_cmd[1], \"-\") == 0)\n\t// \texecve(fullpath, current->av_cmd, envp);\n\tif (is_grep(fullpath) && current->av_cmd && current->av_cmd[1])\n\t{\n\t\tjoined = join_args(&current->av_cmd[1], \"\");\n        //printf(\"Joined args for grep: [%s]\\n\", joined); // Debugging line\n\t\tif (!joined)\n\t\t{\n\t\t\tft_putstr_fd(\"minishell: memory allocation failed\", 2);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tnew_argv[0] = ft_strdup(current->av_cmd[0]);\n\t\tif (!new_argv[0])\n\t\t{\n\t\t\tfree(joined);\n\t\t\tft_putstr_fd(\"minishell: memory allocation failed\", 2);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tnew_argv[1] = joined;\n\t\tnew_argv[2] = NULL;\n\t\texecve(fullpath, new_argv, envp);\n\t\tfree(new_argv[0]);\n\t\tfree(joined);\n\t}\n    else\n    {\n        execve(fullpath, current->av_cmd, envp);\n    }\n\tft_putstr_fd(\"minishell: execve failed\", 2);\n\texit(EXIT_FAILURE);\n}\n","size_bytes":2740},"SOURCE/execute/helpers.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   helpers.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:36:33 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/20 14:25:11 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nstatic size_t\tcalc_total_len(char **av_cmd)\n{\n\tsize_t\tlen;\n\tint\t\ti;\n\n\tlen = 0;\n\ti = 0;\n\twhile (av_cmd[i])\n\t{\n\t\tlen += ft_strlen(av_cmd[i]);\n\t\tif (av_cmd[i + 1])\n\t\t\tlen++;\n\t\ti++;\n\t}\n\treturn (len + 1);\n}\n\nchar\t*ft_join_arguments(char **av_cmd)\n{\n\tchar\t*joined;\n\tint\t\ti;\n\n\tif (!av_cmd || !*av_cmd)\n\t\treturn (NULL);\n\tjoined = malloc(calc_total_len(av_cmd));\n\tif (!joined)\n\t\treturn (NULL);\n\tjoined[0] = '\\0';\n\ti = 0;\n\twhile (av_cmd[i])\n\t{\n\t\tft_strcat(joined, av_cmd[i]);\n\t\tif (av_cmd[i + 1])\n\t\t\tft_strcat(joined, \" \");\n\t\ti++;\n\t}\n\treturn (joined);\n}\n\nvoid\tft_check_fork(pid_t child_pid)\n{\n\tif (child_pid < 0)\n\t\tft_error_exit(\"fork\");\n}\n\nvoid\tft_error_exit(char *error)\n{\n\tperror(error);\n\texit(EXIT_FAILURE);\n}\n\nvoid\tft_free_strings(char **cmd_array)\n{\n\tint\ti;\n\n\ti = 0;\n\twhile (cmd_array[i])\n\t{\n\t\tfree(cmd_array[i]);\n\t\ti++;\n\t}\n\tfree(cmd_array);\n}\n","size_bytes":1767},"SOURCE/execute/heredoc.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   heredoc.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 11:08:32 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/15 10:41:27 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nstatic int\thandle_heredoc_eof(char *line, t_shell *shell, char *delimiter)\n{\n\twrite(STDOUT_FILENO, \"\\n\", 1);\n\tft_putstr_fd(\"minishell: warning: here-document at line \", STDERR_FILENO);\n\tft_putnbr_fd(shell->line_cnt, STDERR_FILENO);\n\tft_putstr_fd(\" delimited by end-of-file (wanted `\", STDERR_FILENO);\n\tft_putstr_fd(delimiter, STDERR_FILENO);\n\tft_putstr_fd(\"')\\n\", STDERR_FILENO);\n\tfree(line);\n\treturn (-1);\n}\n\nstatic int\tis_heredoc_delimiter(char *line, char *delimiter)\n{\n\tif (!line)\n\t\treturn (0);\n\tif (ft_strncmp(line, delimiter, ft_strlen(delimiter)) == 0\n\t\t&& (line[ft_strlen(delimiter)] == '\\n'\n\t\t\t|| line[ft_strlen(delimiter)] == '\\0'))\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_heredoc_read_loop(int pipe_write_fd, char *delimiter, t_shell *shell)\n{\n\tchar\t*line;\n\n\twhile (1)\n\t{\n\t\twrite(STDOUT_FILENO, \"> \", 2);\n\t\tline = get_next_line(STDIN_FILENO);\n\t\tif (!line || g_gb.last_sig == SIGINT)\n\t\t{\n\t\t\tif (g_gb.last_sig != SIGINT)\n\t\t\t\treturn (handle_heredoc_eof(line, shell, delimiter));\n\t\t\tfree(line);\n\t\t\treturn (-1);\n\t\t}\n\t\tif (is_heredoc_delimiter(line, delimiter))\n\t\t{\n\t\t\tshell->line_cnt++;\n\t\t\tfree(line);\n\t\t\tbreak ;\n\t\t}\n\t\tif (!(ft_strcmp (line, \"\\n\") == 0))\n\t\t\tshell->line_cnt++;\n\t\twrite(pipe_write_fd, line, ft_strlen(line));\n\t\tfree(line);\n\t}\n\treturn (0);\n}\n\nvoid\tft_heredoc(t_comnd *cmds, t_shell *shell)\n{\n\tint\t\tpipe_fd[2];\n\n\tif (!cmds->delimiter)\n\t{\n\t\tft_putstr_fd(\"minishell: heredoc: missing delimiter\\n\", 2);\n\t\treturn ;\n\t}\n\tif (pipe(pipe_fd) < 0)\n\t\tft_error_exit(\"pipe\");\n\t//g_gb.last_sig = SIGINT_HEREDOC;\n\tif (ft_heredoc_read_loop(pipe_fd[1], cmds->delimiter, shell) == -1)\n\t{\n\t\tclose(pipe_fd[1]);\n\t\tclose(pipe_fd[0]);\n\t\tcmds->infile = -1;\n\t\tg_gb.last_sig = 0;\n\t\treturn ;\n\t}\n\tclose(pipe_fd[1]);\n\tcmds->infile = pipe_fd[0];\n\t\n\tft_pipe_up_bonus(cmds, shell);\n\tget_next_line(-1);\n\tg_gb.last_sig = 0;\n}\n\nint\tft_start_execution(t_comnd *cmds, t_shell *shell)\n{\n\tt_comnd\t*cmd;\n\n\tcmd = cmds;\n\tif (!cmds)\n\t{\n\t\tft_putstr_fd(\"minishell: missing commands\\n\", 2);\n\t\treturn (1);\n\t}\n\tif (cmd->av_cmd[0] && (strcmp(cmd->av_cmd[0], \"minishell\") == 0\n\t\t|| strcmp(cmd->av_cmd[0], \"./minishell\") == 0))\n    \treturn (handle_nested_minishell(cmd->av_cmd, shell->envp));\n\twhile (cmd)\n\t{\n\t\tif (cmd->delimiter)\n\t\t{\n\t\t\tft_heredoc(cmd, shell);\n\t\t\treturn (0);\n\t\t}\n\t\tcmd = cmd->next;\n\t}\n\t// Open redirection files before executing pipeline\n\t//ft_open_main(cmds, 0);\n\tft_pipe_up_bonus(cmds, shell);\n\tget_next_line(-1);\n\treturn (0);\n}\n","size_bytes":3341},"SOURCE/execute/open_fd1.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   open_fd1.c                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:44:50 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/21 12:07:27 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nvoid\topen_infile(t_comnd *cmd, int in_child)\n{\n\tif (cmd->infile != -1)\n\t\tclose(cmd->infile);\n\tcmd->infile = open(cmd->infile_name, O_RDONLY);\n\tif (cmd->infile < 0)\n\t{\n\t\t// Always print the error message (like bash does)\n\t\tft_putstr_fd(\"Minishell: \", 2);\n\t\tft_putstr_fd(cmd->infile_name, 2);\n\t\tft_putstr_fd(\": No such file or directory\\n\", 2);\n\t\t\n\t\tif (in_child)\n\t\t\texit(1);\n\t\telse\n\t\t\tcmd->infile = -1;\n\t}\n}\n\nstatic void\tclose_existing_outfile(t_comnd *last)\n{\n\tif (last->outfile != -1)\n\t{\n\t\tclose(last->outfile);\n\t\tlast->outfile = -1;\n\t}\n}\n\nstatic void\topen_from_heredoc(t_comnd *last, int infile_fd)\n{\n\tif (infile_fd >= 0)\n\t\tlast->outfile = dup(infile_fd);\n\telse\n\t\tlast->outfile = -1;\n}\n\nstatic void\topen_normal_outfile(t_comnd *last)\n{\n\tif (last->redirec_type == TOKEN_REDIRECT_OUT)\n\t\tlast->outfile = open(last->outfile_name,\n\t\t\t\tO_WRONLY | O_CREAT | O_TRUNC, 0644);\n\telse if (last->redirec_type == TOKEN_APPEND)\n\t\tlast->outfile = open(last->outfile_name,\n\t\t\t\tO_WRONLY | O_CREAT | O_APPEND, 0644);\n\telse\n\t\tlast->outfile = -1;\n\tif (last->outfile < 0)\n\t{\n\t\tft_putstr_fd(\"minishell: \", 2);\n\t\tft_putstr_fd(last->outfile_name, 2);\n\t\tft_putstr_fd(\": \", 2);\n\t\tft_putstr_fd(strerror(errno), 2);\n\t\tft_putstr_fd(\"\\n\", 2);\n\t\tlast->outfile = -1;\n\t}\n}\n\nvoid\topen_outfile(t_comnd *last, int here_flag, int infile_fd)\n{\n\tif (!last || !last->outfile_name)\n\t\treturn ;\n\tclose_existing_outfile(last);\n\tif (here_flag)\n\t\topen_from_heredoc(last, infile_fd);\n\telse\n\t\topen_normal_outfile(last);\n\t\n\t// If output redirection failed, mark it so the child process can handle it\n\tif (last->outfile < 0)\n\t{\n\t\t// Set a flag to indicate redirection failure\n\t\tlast->outfile = -2; // Use -2 to indicate \"redirection failed\"\n\t}\n}\n\n// void\topen_outfile(t_comnd *last, int here_flag, int infile_fd, int in_child)\n// {\n// \t(void)in_child;\n// \tif (!last || !last->outfile_name)\n// \t\treturn ;\n// \tif (last->outfile != -1)\n// \t{\n// \t\tclose(last->outfile);\n// \t\tlast->outfile = -1;\n// \t}\n// \tif (here_flag)\n// \t{\n// \t\tif (infile_fd >= 0)\n// \t\t\tlast->outfile = dup(infile_fd);\n// \t\telse\n// \t\t\tlast->outfile = -1;\n// \t\treturn ;\n// \t}\n// \tif (last->redirec_type == TOKEN_REDIRECT_OUT)\n// \t\tlast->outfile = open(last->outfile_name, O_WRONLY | O_CREAT | O_TRUNC,\n// \t\t\t\t0644);\n// \telse if (last->redirec_type == TOKEN_APPEND)\n// \t\tlast->outfile = open(last->outfile_name, O_WRONLY | O_CREAT | O_APPEND,\n// \t\t\t\t0644);\n// \telse\n// \t\tlast->outfile = -1;\n// \tif (last->outfile < 0)\n// \t{\n// \t\tperror(\"open_outfile\");\n// \t\tlast->outfile = -1;\n// \t}\n// }\n","size_bytes":3431},"SOURCE/execute/open_fd2.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   open_fd2.c                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 10:48:12 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/02 09:32:10 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nvoid\tft_open_main(t_comnd *cmds, int here_flag)\n{\n\tt_comnd\t*current;\n\n\tif (g_gb.last_sig == SIGINT)\n\t\treturn ;\n\t\n\t// Open redirections for each command in the pipeline\n\t// Don't abort pipeline - let individual commands handle their redirection failures\n\tcurrent = cmds;\n\twhile (current)\n\t{\n\t\t// Open input file if specified\n\t\tif (!here_flag && current->infile_name)\n\t\t{\n\t\t\topen_infile(current, 0);\n\t\t\t// Individual commands will handle their own redirection failures\n\t\t}\n\t\t\n\t\t// Open output file if specified\n\t\tif (current->outfile_name)\n\t\t{\n\t\t\topen_outfile(current, here_flag, -1);\n\t\t\t// Individual commands will handle their own redirection failures\n\t\t}\n\t\t\n\t\tcurrent = current->next;\n\t}\n}\n\nvoid\tft_open_last_outfile(t_comnd *cmds)\n{\n\tt_comnd\t*last;\n\tint\t\tflags;\n\n\tlast = cmds;\n\twhile (last && last->next)\n\t\tlast = last->next;\n\tif (last && last->outfile_name)\n\t{\n\t\tflags = O_WRONLY | O_CREAT | O_TRUNC;\n\t\tlast->outfile = open(last->outfile_name, flags, 0644);\n\t\tif (last->outfile < 0)\n\t\t{\n\t\t\tperror(last->outfile_name);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n}\n\nint\tdevnull_open(int fd)\n{\n\tfd = open(\"/dev/null\", O_RDONLY);\n\tif (fd >= 0)\n\t{\n\t\tdup2(fd, STDIN_FILENO);\n\t\tclose(fd);\n\t}\n\treturn (fd);\n}\n\nvoid\tft_child_setup(t_comnd *current, int prev_fd, int pipe_write)\n{\n\tint\tdevnull;\n\n\t(void)devnull;\n\tif (current->infile >= 0)\n\t{\n\t\tdup2(current->infile, STDIN_FILENO);\n\t\tclose(current->infile);\n\t}\n\telse if (prev_fd != -1)\n\t{\n\t\tdup2(prev_fd, STDIN_FILENO);\n\t\tclose(prev_fd);\n\t}\n\telse\n\t\tdevnull = devnull_open(-1);\n\tif (pipe_write >= 0)\n\t{\n\t\tdup2(pipe_write, STDOUT_FILENO);\n\t\tclose(pipe_write);\n\t}\n\tif (current->outfile >= 0)\n\t{\n\t\tdup2(current->outfile, STDOUT_FILENO);\n\t\tclose(current->outfile);\n\t}\n}\n\n// void\tft_child_setup(t_comnd *current, int prev_fd, int pipe_write)\n// {\n// \tint\tdevnull;\n\n// \tif (current->infile >= 0)\n// \t{\n// \t\tdup2(current->infile, STDIN_FILENO);\n// \t\tclose(current->infile);\n// \t}\n// \telse if (prev_fd != -1)\n// \t{\n// \t\tdup2(prev_fd, STDIN_FILENO);\n// \t\tclose(prev_fd);\n// \t}\n// \telse\n// \t{\n// \t\tdevnull = open(\"/dev/null\", O_RDONLY);\n// \t\tif (devnull >= 0)\n// \t\t{\n// \t\t\tdup2(devnull, STDIN_FILENO);\n// \t\t\tclose(devnull);\n// \t\t}\n// \t}\n// \tif (pipe_write >= 0)\n// \t{\n// \t\tdup2(pipe_write, STDOUT_FILENO);\n// \t\tclose(pipe_write);\n// \t}\n// \tif (current->outfile >= 0)\n// \t{\n// \t\tdup2(current->outfile, STDOUT_FILENO);\n// \t\tclose(current->outfile);\n// \t}\n// }\n","size_bytes":3303},"SOURCE/expansion/exap_utils.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   exap_utils.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 13:58:49 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/28 10:33:40 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tis_valid_var_char(char c, int start)\n{\n\tif (start)\n\t\treturn (ft_isalpha(c) || c == '_');\n\treturn (ft_isalnum(c) || c == '_');\n}\n\nchar\t*ft_dup_env_value(char *var_name, t_shell *shell)\n{\n\tchar\t*ptr_env_list;\n\tchar\t*ptr_array_value;\n\n\t// First check regular environment variables\n\tptr_env_list = get_env_value(var_name, shell->env_list);\n\tif (ptr_env_list)\n\t\treturn (ft_strdup(ptr_env_list));\n\t\n\t// Then check array variables (return first element)\n\tptr_array_value = ft_get_array_first_element(var_name, shell->array_list);\n\tif (ptr_array_value)\n\t\treturn (ft_strdup(ptr_array_value));\n\t\n\treturn (ft_strdup(\"\"));\n}\n\nchar\t*ft_get_lastcmd_string(int status)\n{\n\treturn (ft_itoa(status));\n}\n\nint\tft_append_piece(char **expand_string, char *piece)\n{\n\tchar\t*tmp;\n\n\tif (!piece)\n\t{\n\t\tfree(*expand_string);\n\t\treturn (0);\n\t}\n\ttmp = ft_strjoin(*expand_string, piece);\n\tfree(*expand_string);\n\tfree(piece);\n\t*expand_string = tmp;\n\tif (!*expand_string)\n\t\treturn (0);\n\treturn (1);\n}\n\nchar\t*ft_char_to_str(char x)\n{\n\tchar\tbuf[2];\n\n\tbuf[0] = x;\n\tbuf[1] = '\\0';\n\treturn (ft_strdup(buf));\n}\n\nint\tft_append_char_to_expand(char **expand_string, char c)\n{\n    char\t*tmp;\n\n    tmp = ft_char_to_str(c);\n    if (!tmp)\n        return (0);\n    return (ft_append_piece(expand_string, tmp));\n}\n","size_bytes":2194},"SOURCE/expansion/expan_utils2.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   expan_utils2.c                                     :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/27 12:10:46 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/28 10:28:04 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nstatic char\t*append_piece(char *result, char *piece)\n{\n\tchar\t*tmp;\n\n\tif (!piece)\n\t{\n\t\tfree(result);\n\t\treturn (NULL);\n\t}\n\ttmp = ft_strjoin(result, piece);\n\tfree(result);\n\tfree(piece);\n\treturn (tmp);\n}\n\nstatic char\t*extract_normal_text(const char *content, size_t *i)\n{\n\tsize_t\tstart;\n\n\tstart = *i;\n\twhile (content[*i] && content[*i] != '$')\n\t\t(*i)++;\n\treturn (ft_substr(content, start, *i - start));\n}\n\nstatic char\t*extract_piece(const char *content, size_t *i, t_shell *shell)\n{\n\tif (content[*i] == '$')\n\t{\n\t\t(*i)++;\n\t\treturn (ft_process_dollar(content, i, shell));\n\t}\n\telse\n\t\treturn (extract_normal_text(content, i));\n}\n\nchar\t*ft_expand_string(const char *content, t_shell *shell)\n{\n\tsize_t\ti;\n\tchar\t*result;\n\tchar\t*piece;\n\n\tif (!content)\n\t\treturn (NULL);\n\tresult = ft_strdup(\"\");\n\tif (!result)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (content[i])\n\t{\n\t\tpiece = extract_piece(content, &i, shell);\n\t\tresult = append_piece(result, piece);\n\t\tif (!result)\n\t\t\treturn (NULL);\n\t}\n\treturn (result);\n}\n\nchar\t*ft_process_quote(const char *input, size_t *idx_ptr, t_shell *shell)\n{\n\tchar\tquote;\n\tsize_t\tstart;\n\tchar\t*content;\n\tchar\t*expanded;\n\n\tquote = input[*idx_ptr];\n\t(*idx_ptr)++;\n\tstart = *idx_ptr;\n\twhile (input[*idx_ptr] && input[*idx_ptr] != quote)\n\t\t(*idx_ptr)++;\n\tcontent = ft_substr(input, start, *idx_ptr - start);\n\tif (!content)\n\t\treturn (NULL);\n\tif (input[*idx_ptr] == quote)\n\t\t(*idx_ptr)++;\n\tif (quote == '\"')\n\t{\n\t\texpanded = ft_expand_string(content, shell);\n\t\tfree(content);\n\t\treturn (expanded);\n\t}\n\treturn (content);\n}\n\n\n\n","size_bytes":2448},"SOURCE/expansion/expansion.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   expansion.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/27 12:21:12 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/11 14:55:46 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\n// static char  *ft_expand_braced_var(const char *input, size_t *idx_ptr,\n//              t_shell *shell)\n// {\n//      size_t  start;\n//      char    *var_name;\n//      char    *string;\n\n//      (*idx_ptr)++;\n//      start = *idx_ptr;\n//      while (input[*idx_ptr] && input[*idx_ptr] != '}')\n//              (*idx_ptr)++;\n//      if (input[*idx_ptr] != '}')\n//              return (ft_strdup(\"${\"));\n//      var_name = ft_substr(input, start, *idx_ptr - start);\n//      if (!var_name)\n//              return (NULL);\n//      string = ft_dup_env_value(var_name, shell);\n//      if (!string)\n//              string = ft_strdup(\"\");\n//      free(var_name);\n//      (*idx_ptr)++;\n//      return (string);\n// }\n\n// static char  *expand_last_status(size_t *idx_ptr, t_shell *shell)\n// {\n//      (*idx_ptr)++;\n//      return (ft_get_lastcmd_string(shell->last_status));\n// }\n\n// char *ft_process_dollar(const char *input, size_t *idx_ptr, t_shell *shell)\n// {\n//      size_t  start;\n//      char    *string;\n//      char    *var_name;\n\n//      if (input[*idx_ptr] == '?')\n//              return (expand_last_status(idx_ptr, shell));\n//     if (input[*idx_ptr]  == '$') // special case: PID\n//     {\n//         (*idx_ptr)++;\n//         return ft_itoa(getpid());\n//     }\n//      if (input[*idx_ptr] == '{')\n//              return (ft_expand_braced_var(input, idx_ptr, shell));\n//      if (is_valid_var_char(input[*idx_ptr], 1))\n//      {\n//              start = *idx_ptr;\n//              while (input[*idx_ptr] && is_valid_var_char(input[*idx_ptr], 0))\n//                      (*idx_ptr)++;\n//              var_name = ft_substr(input, start, *idx_ptr - start);\n//              if (!var_name)\n//                      return (NULL);\n//              string = ft_dup_env_value(var_name, shell);\n//              if (!string)\n//                      string = ft_strdup(\"\");\n//              free(var_name);\n//              return (string);\n//      }\n//      // When $ is not followed by valid variable char, treat as literal $\n//      return (ft_strdup(\"$\"));\n// }\nchar *ft_getenv(t_shell *shell, const char *varname)\n{\n    t_env_var *env;\n\n    if (!shell || !varname)\n        return NULL;\n\n    env = shell->env_list;\n    while (env)\n    {\n        if (ft_strcmp(env->envar_name, varname) == 0)\n            return env->envar_value; // return pointer to value\n        env = env->next_envar;\n    }\n    return NULL; // not found\n}\n\nchar *ft_process_dollar(const char *str, size_t *i, t_shell *shell)\n{\n    char varname[256];\n    size_t j = 0;\n    char *value;\n\n    if (str[*i] == '?') // special case: last status code\n    {\n        (*i)++;\n        return ft_itoa(shell->last_status);\n    }\n    if (str[*i] == '$') // special case: PID\n    {\n        (*i)++;\n        return ft_itoa(getpid());\n    }\n    if (str[*i] == '{') // ${VAR} syntax\n    {\n        (*i)++; // skip '{'\n        while (str[*i] && str[*i] != '}' && j < sizeof(varname) - 1)\n            varname[j++] = str[(*i)++];\n        if (str[*i] == '}')\n            (*i)++; // skip '}'\n        varname[j] = '\\0';\n    }\n    else\n    {\n        // Normal variable name [A-Za-z_][A-Za-z0-9_]*\n        if (!ft_isalpha(str[*i]) && str[*i] != '_')\n            return ft_strdup(\"$\"); // \"$x\" invalid start → keep '$'\n        while ((ft_isalnum(str[*i]) || str[*i] == '_') && j < sizeof(varname) - 1)\n            varname[j++] = str[(*i)++];\n        varname[j] = '\\0';\n    }\n\n    // Lookup variable in env\n    value = ft_getenv(shell, varname);\n    if (!value)\n        return ft_strdup(\"\"); // undefined → empty\n    return ft_strdup(value);\n}\n\nchar *ft_expand_tilde(const char *str, size_t *i, t_shell *shell)\n{\n    char *home;\n    \n    (void)shell;\n    if (str[*i] == '~')\n    {\n        (*i)++;\n        home = getenv(\"HOME\");\n        if (home)\n            return ft_strdup(home);\n        else\n            return ft_strdup(\"~\");\n    }\n    return ft_strdup(\"~\");\n}\n\nchar *ft_create_expansion_main(const char *input, t_token *token, t_shell *shell)\n{\n    size_t i;\n    char *expand_string;\n    char *piece;\n\n    (void)input; // input is unused now, but kept for compatibility\n    \n    // SINGLE-quoted: return literal content without expansion\n    if (token && token->quote == SINGLE)\n        return ft_strdup(token->token_value);\n\n    // DOUBLE-quoted or unquoted: expand $ and ~\n    expand_string = ft_strdup(\"\");\n    if (!expand_string)\n        return NULL;\n\n    i = 0;\n    // Handle tilde expansion at the beginning for unquoted tokens\n    if (token->quote == NA && token->token_value[0] == '~' && (token->token_value[1] == '\\0' || token->token_value[1] == '/'))\n    {\n        piece = ft_expand_tilde(token->token_value, &i, shell);\n        if (!piece || !ft_append_piece(&expand_string, piece))\n            return NULL;\n    }\n    \n    while (token->token_value[i])\n    {\n        if (token->token_value[i] == '$')\n        {\n            i++;\n            piece = ft_process_dollar(token->token_value, &i, shell);\n            if (!piece || !ft_append_piece(&expand_string, piece))\n                return NULL;\n        }\n        else if (token->token_value[i] == '\\\\' && token->token_value[i + 1])\n        {\n            i++; // skip backslash\n            if (token->quote == DOUBLE)\n            {\n                // Handle escape sequences in double quotes\n                if (token->token_value[i] == '$' || token->token_value[i] == '\"' || \n                    token->token_value[i] == '\\\\' || token->token_value[i] == '\\n')\n                {\n                    piece = ft_char_to_str(token->token_value[i]);\n                }\n                else\n                {\n                    // Keep both backslash and character for other escapes\n                    char temp[3] = {'\\\\', token->token_value[i], '\\0'};\n                    piece = ft_strdup(temp);\n                }\n            }\n            else\n            {\n                // In unquoted context, backslash escapes the next character\n                piece = ft_char_to_str(token->token_value[i]);\n            }\n            if (!piece || !ft_append_piece(&expand_string, piece))\n                return NULL;\n            i++;\n        }\n        else\n        {\n            piece = ft_char_to_str(token->token_value[i]);\n            if (!piece || !ft_append_piece(&expand_string, piece))\n                return NULL;\n            i++;\n        }\n    }\n\n    return expand_string;\n}\n\n\n\n\n\n\n\n// char *ft_create_expansion_main(const char *input, t_shell *shell)\n// {\n//     size_t   i;\n//     char     *expand_string;\n//     char     *piece;\n//     int              in_single;\n//     int              in_double;\n\n//     /* If the whole token was single-quoted, everything is literal:\n//      * lexer/parser should have set shell->cmd_list->quote for this arg.\n//      * In that case return a strdup of the input (no expansion). */\n\n//     in_single = 0;\n//     in_double = 0;\n//     if (shell && shell->cmd_list && shell->cmd_list->quote == DOUBLE)\n//         in_double = 1;\n//     if (shell && shell->cmd_list && shell->cmd_list->quote == SINGLE)\n//     {\n//         return (ft_strdup(input));\n//         in_single = 1;\n//     }\n\n//     expand_string = ft_strdup(\"\");\n//     if (!expand_string)\n//         return (NULL);\n//     i = 0;\n//     while (input[i])\n//     {\n//         if (input[i] == '\\'')\n//         {\n//             if (!in_double)\n//                 in_single = !in_single;\n//             else\n//             {\n//                 if (!ft_append_char_to_expand(&expand_string, '\\''))\n//                     return (NULL);\n//             }\n//             i++;\n//         }\n//         else if (input[i] == '\"')\n//         {\n//             if (!in_single)\n//                 in_double = !in_double;\n//             else\n//             {\n//                 if (!ft_append_char_to_expand(&expand_string, '\"'))\n//                     return (NULL);\n//             }\n//             i++;\n//         }\n//         else if (input[i] == '$' && !in_single)\n//         {\n//             i++;\n//             piece = ft_process_dollar(input, &i, shell);\n//             if (!ft_append_piece(&expand_string, piece))\n//                 return (NULL);\n//         }\n//         else\n//         {\n//             piece = ft_char_to_str(input[i++]);\n//             if (!ft_append_piece(&expand_string, piece))\n//                 return (NULL);\n//         }\n//     }\n//     return (expand_string);\n// }\n// Removed unused remove_empty_arguments function\n\nvoid    ft_expand_cmds(t_comnd *cmds, t_shell *shell)\n{\n    char        *expanded;\n    char        *group;\n    char        *temp;\n    t_token     *tok;\n    t_comnd     *saved_shell_cmds;\n    char        **new_av;\n    int         argc;\n    int         capacity;\n\n    /* preserve original shell->cmd_list pointer and restore later */\n    saved_shell_cmds = shell->cmd_list;\n\n    while (cmds)\n    {\n        shell->cmd_list = cmds; // if needed by ft_process_dollar, etc.\n        tok = cmds->av_cmd_lst;\n        \n        // Initialize new argv array\n        argc = 0;\n        capacity = 8;\n        new_av = malloc(sizeof(char*) * capacity);\n        if (!new_av)\n            return;\n\n        // Process tokens in groups\n        while (tok)\n        {\n            // Start new group\n            group = ft_strdup(\"\");\n            if (!group)\n            {\n                // Cleanup and return\n                for (int i = 0; i < argc; i++)\n                    free(new_av[i]);\n                free(new_av);\n                return;\n            }\n\n            // Process consecutive tokens that should be joined\n            do {\n                expanded = ft_create_expansion_main(NULL, tok, shell);\n                if (expanded)\n                {\n                    temp = ft_strjoin(group, expanded);\n                    free(group);\n                    free(expanded);\n                    group = temp;\n                    if (!group)\n                    {\n                        // Cleanup and return\n                        for (int i = 0; i < argc; i++)\n                            free(new_av[i]);\n                        free(new_av);\n                        return;\n                    }\n                }\n\n                if (!tok->join_with_next)\n                {\n                    tok = tok->next_token;\n                    break;\n                }\n                tok = tok->next_token;\n            } while (tok);\n\n            // Add group to new argv if not empty\n            if (group && ft_strlen(group) > 0)\n            {\n                // Resize array if needed\n                if (argc >= capacity - 1)\n                {\n                    capacity *= 2;\n                    char **temp_av = realloc(new_av, sizeof(char*) * capacity);\n                    if (!temp_av)\n                    {\n                        free(group);\n                        for (int i = 0; i < argc; i++)\n                            free(new_av[i]);\n                        free(new_av);\n                        return;\n                    }\n                    new_av = temp_av;\n                }\n                new_av[argc++] = group;\n            }\n            else\n                free(group);\n        }\n\n        // Null-terminate new array\n        new_av[argc] = NULL;\n\n        // Replace old av_cmd with new one\n        if (cmds->av_cmd)\n        {\n            for (int i = 0; cmds->av_cmd[i]; i++)\n                free(cmds->av_cmd[i]);\n            free(cmds->av_cmd);\n        }\n        cmds->av_cmd = new_av;\n\n        cmds = cmds->next;\n    }\n\n    /* restore original pointer */\n    shell->cmd_list = saved_shell_cmds;\n}\n\n\n// void ft_expand_cmds(t_comnd *cmds, t_shell *shell)\n// {\n//      char    *expanded;\n//      int             i;\n\n//      while (cmds)\n//      {\n//              i = 0;\n//              while (cmds->av_cmd && cmds->av_cmd[i])\n//              {\n//                      expanded = ft_create_expansion_main(cmds->av_cmd[i], shell);\n//                      if (expanded)\n//                      {\n//                              free(cmds->av_cmd[i]);\n//                              cmds->av_cmd[i] = expanded;\n//                      }\n//                      i++;\n//              }\n//              cmds = cmds->next;\n//      }\n// }\n","size_bytes":13105},"SOURCE/gnl/get_next_line_bonus.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   get_next_line_bonus.c                              :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/01/29 19:02:18 by robello-          #+#    #+#             */\n/*   Updated: 2025/08/22 10:17:44 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"get_next_line_bonus.h\"\n\nvoid\tclear_buff(t_buffer *buf)\n{\n\tif (buf->buffer)\n\t{\n\t\tfree(buf->buffer);\n\t\tbuf->buffer = NULL;\n\t}\n\tbuf->bytes_read = 0;\n\tbuf->offset = 0;\n}\n\nchar\t*extract_chunk(t_buffer *buf)\n{\n\tchar\t*chunk;\n\tssize_t\tclen;\n\tssize_t\ti;\n\n\tclen = 0;\n\twhile (buf->offset + clen < buf->bytes_read\n\t\t&& buf->buffer[buf->offset + clen] != '\\n')\n\t\tclen++;\n\tif (buf->offset + clen < buf->bytes_read\n\t\t&& buf->buffer[buf->offset + clen] == '\\n')\n\t\tclen++;\n\tchunk = malloc(clen + 1);\n\tif (!chunk)\n\t\treturn (NULL);\n\ti = -1;\n\twhile (++i < clen)\n\t\tchunk[i] = buf->buffer[buf->offset + i];\n\tchunk[clen] = '\\0';\n\tbuf->offset += clen;\n\treturn (chunk);\n}\n\nchar\t*process_chunk(char *line, t_buffer *buf)\n{\n\tchar\t*chunk;\n\tchar\t*new_line;\n\n\tchunk = extract_chunk(buf);\n\tif (!chunk)\n\t\treturn (free(line), NULL);\n\tnew_line = append_to_line(line, chunk, my_strlen(chunk));\n\tfree(chunk);\n\treturn (new_line);\n}\n\nint\thas_newline(char *line)\n{\n\tsize_t\tlen;\n\n\tif (!line)\n\t\treturn (0);\n\tlen = my_strlen(line);\n\treturn (len > 0 && line[len - 1] == '\\n');\n}\n\nchar\t*get_next_line(int fd)\n{\n\tstatic t_buffer\tbufs[MAX_FD];\n\tchar\t\t\t*line;\n\tt_buffer\t\t*buf;\n\tssize_t\t\t\tread_status;\n\n\tif (fd == -1)\n\t\treturn (clear_all_buffs(bufs, MAX_FD), NULL);\n\tbuf = &bufs[fd];\n\tline = NULL;\n\tif (fd < 0 || fd >= MAX_FD || BUFFER_SIZE <= 0)\n\t\treturn (NULL);\n\twhile (1)\n\t{\n\t\tread_status = read_update(fd, buf);\n\t\tif (read_status == -1)\n\t\t\treturn (free(line), NULL);\n\t\tif (read_status == 0)\n\t\t\treturn (clear_buff(buf), line);\n\t\tline = process_chunk(line, buf);\n\t\tif (!line)\n\t\t\treturn (NULL);\n\t\tif (has_newline(line))\n\t\t\tbreak ;\n\t}\n\treturn (line);\n}\n","size_bytes":2507},"SOURCE/gnl/get_next_line_utils_bonus.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   get_next_line_utils_bonus.c                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/01/29 19:02:54 by robello-          #+#    #+#             */\n/*   Updated: 2025/08/22 10:17:08 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"get_next_line_bonus.h\"\n\nvoid\tclear_all_buffs(t_buffer *bufs, int max_fds)\n{\n\tint\tx;\n\n\tx = 0;\n\twhile (x < max_fds)\n\t{\n\t\tclear_buff(&bufs[x]);\n\t\tx++;\n\t}\n}\n\nsize_t\tmy_strlen(const char *str)\n{\n\tsize_t\tlen;\n\n\tlen = 0;\n\tif (!str)\n\t\treturn (0);\n\twhile (str[len])\n\t\tlen++;\n\treturn (len);\n}\n\nchar\t*append_to_line(char *line, const char *chunk, ssize_t clen)\n{\n\tchar\t*new_line;\n\tsize_t\tllen;\n\tsize_t\ttotal;\n\tsize_t\ti;\n\n\tllen = my_strlen(line);\n\ttotal = llen + clen;\n\tnew_line = malloc(total + 1);\n\tif (!new_line)\n\t\treturn (free(line), NULL);\n\ti = 0;\n\twhile (i < llen)\n\t{\n\t\tnew_line[i] = line[i];\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (i < (size_t)clen)\n\t{\n\t\tnew_line[llen + i] = chunk[i];\n\t\ti++;\n\t}\n\tnew_line[total] = '\\0';\n\tfree(line);\n\treturn (new_line);\n}\n\nssize_t\tallocate_buffer(t_buffer *buf)\n{\n\tif (!buf->buffer)\n\t{\n\t\tbuf->buffer = malloc(BUFFER_SIZE + 1);\n\t\tif (!buf->buffer)\n\t\t{\n\t\t\tbuf->bytes_read = -1;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\treturn (0);\n}\n\nssize_t\tread_update(int fd, t_buffer *buf)\n{\n\tssize_t\tread_result;\n\n\tif (buf->offset >= buf->bytes_read)\n\t{\n\t\tif (allocate_buffer(buf) == -1)\n\t\t\treturn (-1);\n\t\tread_result = read(fd, buf->buffer, BUFFER_SIZE);\n\t\tif (read_result < 0 || read_result == 0)\n\t\t{\n\t\t\tif (read_result < 0)\n\t\t\t\tbuf->bytes_read = -1;\n\t\t\tfree(buf->buffer);\n\t\t\tbuf->buffer = NULL;\n\t\t\tbuf->bytes_read = 0;\n\t\t\tbuf->offset = 0;\n\t\t\treturn (read_result);\n\t\t}\n\t\tbuf->bytes_read = read_result;\n\t\tbuf->offset = 0;\n\t\tbuf->buffer[read_result] = '\\0';\n\t}\n\treturn (buf->bytes_read);\n}\n","size_bytes":2376},"SOURCE/lexer/lexer.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   lexer.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/29 19:07:52 by robello           #+#    #+#             */\n/*   Updated: 2025/09/15 13:16:11 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nstatic int      is_potential_array_assignment(const char *input_line, int start_pos)\n{\n        int     i;\n\n        i = start_pos;\n        // Look for pattern: IDENTIFIER=( but reject IDENTIFIER=((\n        while (input_line[i] && (ft_isalnum(input_line[i]) || input_line[i] == '_'))\n                i++;\n        if (input_line[i] != '=')\n                return (0);\n        i++;\n        if (input_line[i] != '(')\n                return (0);\n        // Reject double parentheses - this should be a syntax error\n        if (input_line[i + 1] == '(')\n                return (0);\n        return (1);\n}\n\nt_token *lex_word(const char *input_line, int *input_ptr)\n{\n        t_token *token;\n        char    *value;\n        int             start;\n        int             paren_depth;\n        int             is_array_assignment;\n\n        paren_depth = 0;\n        start = *input_ptr;\n        is_array_assignment = is_potential_array_assignment(input_line, start);\n        if (is_array_assignment)\n        {\n                // For array assignments,\n                        //include parentheses and spaces in the word token\n                while (input_line[*input_ptr])\n                {\n                        if (input_line[*input_ptr] == '(')\n                                paren_depth++;\n                        else if (input_line[*input_ptr] == ')')\n                        {\n                                paren_depth--;\n                                (*input_ptr)++;\n                                if (paren_depth == 0)\n                                        break ;\n                                continue ;\n                        }\n                        // Allow spaces inside parentheses for array assignments\n                        else if (ft_is_space(input_line[*input_ptr]) && paren_depth == 0)\n                                break ;\n                        (*input_ptr)++;\n                }\n        }\n        else\n        {\n                // Normal word parsing with backslash escape handling\n                while (ft_is_word_char(input_line[*input_ptr])\n                        || input_line[*input_ptr] == '\\\\')\n                {\n                        if (input_line[*input_ptr] == '\\\\' && input_line[*input_ptr + 1])\n                                (*input_ptr) += 2; // Skip escaped character\n                        else\n                                (*input_ptr)++;\n                }\n        }\n        value = ft_substr(input_line, start, *input_ptr - start);\n        if (!value)\n                return (NULL);\n        token = ft_new_token(TOKEN_WORD, value, 0);\n        if (!token)\n                free(value);\n        return (token);\n}\n\nt_token *get_next_token(const char *input_line, int *input_ptr)\n{\n        char    x;\n\n        while (ft_is_space(input_line[*input_ptr]))\n                (*input_ptr)++;\n        if (input_line[*input_ptr] == '\\0')\n                return (NULL);\n        x = input_line[*input_ptr];\n        if (ft_is_single_quote(x))\n                return (lex_single_quote(input_line, input_ptr));\n        if (ft_is_double_quote(x))\n                return (lex_double_quote(input_line, input_ptr));\n        if (ft_is_metacharacter(x))\n                return (lex_metacharacter(input_line, input_ptr));\n        return (lex_word(input_line, input_ptr));\n}\n\n// Helper function to get next token without skipping initial spaces\nstatic t_token  *get_next_token_preserve_space(const char *input_line,\n                int *input_ptr, int *had_space)\n{\n        char    x;\n\n        *had_space = 0;\n        while (ft_is_space(input_line[*input_ptr]))\n        {\n                *had_space = 1;\n                (*input_ptr)++;\n        }\n        if (input_line[*input_ptr] == '\\0')\n                return (NULL);\n        x = input_line[*input_ptr];\n        if (ft_is_single_quote(x))\n                return (lex_single_quote(input_line, input_ptr));\n        if (ft_is_double_quote(x))\n                return (lex_double_quote(input_line, input_ptr));\n        if (ft_is_metacharacter(x))\n                return (lex_metacharacter(input_line, input_ptr));\n        return (lex_word(input_line, input_ptr));\n}\n\n// Helper function to concatenate two token values\nstatic char     *concat_token_values(const char *val1, const char *val2)\n{\n        char    *result;\n\n        size_t len1, len2;\n        if (!val1)\n                val1 = \"\";\n        if (!val2)\n                val2 = \"\";\n        len1 = ft_strlen(val1);\n        len2 = ft_strlen(val2);\n        result = malloc(len1 + len2 + 1);\n        if (!result)\n                return (NULL);\n        ft_strlcpy(result, val1, len1 + 1);\n        ft_strlcat(result, val2, len1 + len2 + 1);\n        return (result);\n}\n\nt_token *ft_lexer_main(char *input_line)\n{\n        int             input_ptr;\n        t_token *first;\n        t_token *last;\n        t_token *token;\n        int             had_space;\n        char    *new_value;\n        // int          prev_quote;\n        // int          curr_quote;\n\n        input_ptr = 0;\n        first = NULL;\n        last = NULL;\n        if (!input_line || !*input_line)\n                return (NULL);\n        while (input_line[input_ptr])\n        {\n                token = get_next_token_preserve_space(input_line, &input_ptr,\n                                &had_space);\n                if (!token)\n                {\n                        free_tokens(first);\n                        return (NULL);\n                }\n\n                // Set join_with_next flag for the previous token\n                if (last)\n                        last->join_with_next = !had_space;\n\n                // Check if we can concatenate with previous token\n                // Only concatenate if quote contexts match to preserve expansion semantics\n                if (!had_space && last && last->type == TOKEN_WORD\n                        && token->type == TOKEN_WORD && last->quote == token->quote)\n                {\n                        // Concatenate with previous token (same quote context)\n                        new_value = concat_token_values(last->token_value,\n                                        token->token_value);\n                        if (!new_value)\n                        {\n                                free_tokens(first);\n                                free(token->token_value);//added\n                                free(token); //added\n                                return (NULL);\n                        }\n                        // Quote context remains the same since both tokens have same quote type\n                        last->quote = token->quote;\n\n                        free(last->token_value);\n                        last->token_value = new_value;\n                        \n                        // Free the current token since we merged it\n                        free(token->token_value);\n                        free(token);\n                }\n                else\n                {\n                        // Add as new token\n                        token->join_with_next = 0; // Initialize flag\n                        if (!first)\n                                first = token;\n                        else\n                                last->next_token = token;\n                        last = token;\n                }\n        }\n        return (first);\n}\n\n// t_token      *ft_lexer_main(const char *input_line)\n// {\n//      int             input_ptr;\n//      t_token *first;\n//      t_token *last;\n//      t_token *token;\n//      int             had_space;\n//      char    *new_value;\n        \n//      input_ptr = 0;\n//      first = NULL;\n//      last = NULL;\n        \n//      if (!input_line || !*input_line)\n//              return (NULL);\n\n//      while (input_line[input_ptr])\n//      {\n//              token = get_next_token_preserve_space(input_line, &input_ptr, &had_space);\n//              if (!token)\n//              {\n//                      free_tokens(first);\n//                      return (NULL);\n//              }\n                \n//              // Check if we can concatenate with previous token\n//              if (!had_space && last && last->type == TOKEN_WORD && token->type == TOKEN_WORD)\n//              {\n//                      // Concatenate with previous token\n//                      new_value = concat_token_values(last->token_value, token->token_value);\n//                      if (!new_value)\n//                      {\n//                              free_tokens(first);\n//                              return (NULL);\n//                      }\n//                      free(last->token_value);\n//                      last->token_value = new_value;\n//                      // Free the current token since we merged it\n//                      free(token->token_value);\n//                      free(token);\n//              }\n//              else\n//              {\n//                      // Add as new token\n//                      if (!first)\n//                              first = token;\n//                      else\n//                              last->next_token = token;\n//                      last = token;\n//              }\n//      }\n//      return (first);\n// }\n","size_bytes":10086},"SOURCE/lexer/lexer_helper.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   lexer_helper.c                                     :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 14:03:13 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/15 17:06:14 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nt_token\t*lex_double_redirect(const char *input_line, int *input_ptr)\n{\n\tt_token_type\ttype;\n\tt_token\t\t\t*token;\n\tchar\t\t\t*value;\n\n\t*input_ptr += 2;\n\tif (input_line[*input_ptr - 2] == '<' && input_line[*input_ptr - 1] == '<')\n\t\ttype = TOKEN_HEREDOC;\n\telse\n\t\ttype = TOKEN_APPEND;\n\tif (type == TOKEN_HEREDOC)\n\t\tvalue = ft_strdup(\"<<\");\n\telse\n\t\tvalue = ft_strdup(\">>\");\n\tif (!value)\n\t\treturn (NULL);\n\ttoken = ft_new_token(type, value, 0);\n\tif (!token)\n\t\tfree(value);\n\treturn (token);\n}\n\nt_token\t*lex_redirect(const char *input_line, int *input_ptr)\n{\n\tt_token_type\ttype;\n\tt_token\t\t\t*token;\n\tchar\t\t\t*value;\n\n\tif (input_line[*input_ptr] == '<')\n\t{\n\t\ttype = TOKEN_REDIRECT_IN;\n\t}\n\telse\n\t{\n\t\ttype = TOKEN_REDIRECT_OUT;\n\t}\n\tvalue = ft_substr(input_line, *input_ptr, 1);\n\tif (!value)\n\t\treturn (NULL);\n\t(*input_ptr)++;\n\ttoken = ft_new_token(type, value, 0);\n\tif (!token)\n\t\tfree(value);\n\treturn (token);\n}\n\nt_token\t*lex_single_quote(const char *input_line, int *input_ptr)\n{\n\tint\t\tstart;\n\tint\t\tlen;\n\tchar\t*value;\n\tt_token\t*token = NULL;\n\n\tstart = *input_ptr + 1;\n\t(*input_ptr)++;\n\twhile (input_line[*input_ptr] && input_line[*input_ptr] != '\\'')\n\t\t(*input_ptr)++;\n\tif (!input_line[*input_ptr])\n\t{\n\t\tft_putstr_fd(\"minishell: syntax error: unclosed quote\\n\", 2);\n\t\treturn (NULL);\n\t}\n\tlen = *input_ptr - start;\n\tvalue = ft_substr(input_line, start, len);\n\tif (!value)\n\t\treturn (NULL);\n\ttoken = ft_new_token(TOKEN_WORD, value, SINGLE);\n\tif (!token)\n\t\tfree(value);\n\t(*input_ptr)++;\n\treturn (token);\n}\n\nt_token\t*lex_double_quote(const char *input_line, int *input_ptr)\n{\n\tint\t\tstart;\n\tint\t\tlen;\n\tchar\t*value;\n\tt_token\t*token = NULL;\n\n\tstart = *input_ptr + 1;\n\t(*input_ptr)++;\n\twhile (input_line[*input_ptr] && input_line[*input_ptr] != '\"')\n\t{\n\t\t// Handle escape sequences in double quotes\n\t\tif (input_line[*input_ptr] == '\\\\' && input_line[*input_ptr + 1])\n\t\t{\n\t\t\t// Skip the escape character and the next character\n\t\t\t(*input_ptr) += 2;\n\t\t}\n\t\telse\n\t\t\t(*input_ptr)++;\n\t}\n\tif (!input_line[*input_ptr])\n\t{\n\t\tft_putstr_fd(\"minishell: syntax error: unclosed quote\\n\", 2);\n\t\treturn (NULL);\n\t}\n\tlen = *input_ptr - start;\n\tvalue = ft_substr(input_line, start, len);\n\tif (!value)\n\t\treturn (NULL);\n\ttoken = ft_new_token(TOKEN_WORD, value, DOUBLE);\n\t\n\tif (!token)\n\t\tfree(value);\n\t(*input_ptr)++;\n\treturn (token);\n}\n\nt_token\t*lex_metacharacter(const char *input_line, int *input_ptr)\n{\n\tt_token\t*token;\n\tchar\tchara[2];\n\n\tif (input_line[*input_ptr + 1] && ((input_line[*input_ptr]\n\t\t\t\t== '<' && input_line[*input_ptr + 1] == '<')\n\t\t\t|| (input_line[*input_ptr]\n\t\t\t\t== '>' && input_line[*input_ptr + 1] == '>')))\n\t\treturn (lex_double_redirect(input_line, input_ptr));\n\tif (ft_is_redirect_char(input_line[*input_ptr]))\n\t\treturn (lex_redirect(input_line, input_ptr));\n\tif (ft_is_pipe(input_line[*input_ptr]))\n\t{\n\t\tchara[0] = input_line[*input_ptr];\n\t\tchara[1] = '\\0';\n\t\t(*input_ptr)++;\n\t\ttoken = ft_new_token(TOKEN_PIPE, ft_strdup(chara), 0);\n\t\tif (!token)\n\t\t\treturn (NULL);\n\t\treturn (token);\n\t}\n\tif (input_line[*input_ptr] == '(' || input_line[*input_ptr] == ')')\n\t{\n\t\tchara[0] = input_line[*input_ptr];\n\t\tchara[1] = '\\0';\n\t\t(*input_ptr)++;\n\t\ttoken = ft_new_token(TOKEN_WORD, ft_strdup(chara), 0);\n\t\tif (!token)\n\t\t\treturn (NULL);\n\t\treturn (token);\n\t}\n\treturn (NULL);\n}\n","size_bytes":4161},"SOURCE/lexer/lexer_utils.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   lexer_utils.c                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 14:01:05 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/25 14:48:30 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tft_is_space(char x)\n{\n\tif (x == ' ' || x == '\\t')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_is_single_quote(char x)\n{\n\tif (x == '\\'')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_is_double_quote(char x)\n{\n\tif (x == '\"')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_is_quote(char x)\n{\n\tif (ft_is_single_quote(x) || ft_is_double_quote(x))\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_is_redirect_char(char x)\n{\n\tif (x == '<' || x == '>')\n\t\treturn (1);\n\treturn (0);\n}\n","size_bytes":1367},"SOURCE/lexer/lexer_utils2.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   lexer_utils2.c                                     :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 14:02:11 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/02 15:39:10 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tft_is_pipe(char x)\n{\n\tif (x == '|')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_is_metacharacter(char x)\n{\n\tif (ft_is_redirect_char(x) || ft_is_pipe(x) || x == '(' || x == ')')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_is_word_char(char x)\n{\n\tif (x && !ft_is_space(x) && !ft_is_metacharacter(x) && !ft_is_quote(x))\n\t\treturn (1);\n\treturn (0);\n}\n\n","size_bytes":1264},"SOURCE/lexer/test_lexer.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   test_lexer.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 14:04:41 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/02 17:13:51 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nconst char\t*token_type_to_str(t_token_type type)\n{\n\tif (type == TOKEN_WORD)\n\t\treturn (\"WORD\");\n\telse if (type == TOKEN_PIPE)\n\t\treturn (\"PIPE\");\n\telse if (type == TOKEN_REDIRECT_IN)\n\t\treturn (\"REDIRECT_IN\");\n\telse if (type == TOKEN_REDIRECT_OUT)\n\t\treturn (\"REDIRECT_OUT\");\n\telse if (type == TOKEN_HEREDOC)\n\t\treturn (\"HEREDOC\");\n\telse if (type == TOKEN_APPEND)\n\t\treturn (\"APPEND\");\n\telse if (type == TOKEN_EOF)\n\t\treturn (\"EOF\");\n\treturn (\"UNKNOWN\");\n}\n\nvoid\tprint_tokens(t_token *tokens)\n{\n\tint\ti;\n\n\ti = 0;\n\twhile (tokens)\n\t{\n\t\tif (tokens->token_value)\n\t\t\tprintf(\"Token %2d: %-12s | Value: '%s' | Quote : %i\\n\", i,\n\t\t\t\ttoken_type_to_str(tokens->type), tokens->token_value,\n\t\t\t\ttokens->quote);\n\t\telse\n\t\t\tprintf(\"Token %2d: %-12s | Value: '%s'\\n\", i,\n\t\t\t\ttoken_type_to_str(tokens->type), \"(null)\");\n\t\ttokens = tokens->next_token;\n\t\ti++;\n\t}\n}\n\nchar\t*add_quotes(const char *s, int i)\n{\n\tchar\t*res;\n\tsize_t\tlen;\n\n\tif (!s)\n\t\treturn (NULL);\n\tlen = ft_strlen(s);\n\t// 2 extra for the quotes + 1 for '\\0'\n\tres = malloc(len + 3);\n\tif (!res)\n\t\treturn (NULL);\n\tif (i == 1)\n\t{\n\t\tres[0] = '\\'';\n\t\tft_memcpy(res + 1, s, len);\n\t\tres[len + 1] = '\\'';\n\t}\n\telse if (i == 2)\n\t{\n\t\tres[0] = '\"';\n\t\tft_memcpy(res + 1, s, len);\n\t\tres[len + 1] = '\"';\n\t}\n\tres[len + 2] = '\\0';\n\treturn (res);\n}\n\nvoid\tquotes_tokens(t_token *tokens)\n{\n\tint\ti;\n\n\ti = 0;\n\twhile (tokens)\n\t{\n\t\tif (tokens->quote == 1)\n\t\t\ttokens->token_value = add_quotes(tokens->token_value, 1);\n\t\telse if (tokens->quote == 2)\n\t\t\ttokens->token_value = add_quotes(tokens->token_value, 2);\n\t\ttokens = tokens->next_token;\n\t\ti++;\n\t}\n}\n\nvoid\tprint_array(char **av)\n{\n\tint\ti;\n\n\tif (!av)\n\t\treturn ;\n\ti = 0;\n\twhile (av[i])\n\t{\n\t\tprintf(\"%s\\t\", av[i]);\n\t\ti++;\n\t}\n}\n\n// Helper: Convert token type enum to string for easy reading\n// const char *token_type_to_str(t_token_type type)\n// {\n//     switch (type) {\n//         case TOKEN_WORD:        return (\"WORD\");\n//         case TOKEN_PIPE:        return (\"PIPE\");\n//         case TOKEN_REDIRECT_IN: return (\"REDIRECT_IN\");\n//         case TOKEN_REDIRECT_OUT:return (\"REDIRECT_OUT\");\n//         case TOKEN_HEREDOC:     return (\"HEREDOC\");\n//         case TOKEN_APPEND:      return (\"APPEND\");\n//         case TOKEN_EOF:         return (\"EOF\");\n//         default:                return (\"UNKNOWN\");\n//     }\n// }","size_bytes":3207},"SOURCE/lexer_t1/lexer_main.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   lexer_main.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/09/15 12:53:46 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/15 13:04:36 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\n// Token types matching bash behavior\n// typedef enum e_token_type\n// {\n// \tTOKEN_WORD,\n// \tTOKEN_PIPE,\n// \tTOKEN_REDIRECT_IN,\n// \tTOKEN_REDIRECT_OUT,\n// \tTOKEN_REDIRECT_APPEND,\n// \tTOKEN_REDIRECT_HEREDOC,\n// \tTOKEN_AND,\n// \tTOKEN_OR,\n// \tTOKEN_SEMICOLON,\n// \tTOKEN_LPAREN,\n// \tTOKEN_RPAREN,\n// \tTOKEN_AMPERSAND,\n// \tTOKEN_EOF,\n// \tTOKEN_NEWLINE\n// }\tt_token_type;\n\n// typedef enum e_quote\n// {\n// \tNA,\n// \tSINGLE,\n// \tDOUBLE\n// }\tt_quote;\n\n// typedef struct s_token\n// {\n// \tt_token_type\t\t\t\ttype;\n// \tt_quote\t\t\t\t\t\tquote;\n// \tchar\t\t\t\t\t\t*token_value;\n// \tstruct s_token\t\t\t\t*next_token;\n// }\t\t\t\t\t\t\t\tt_token;\n\n// Helper function to create a new token\nstatic t_token *create_token(t_token_type type, char *value, t_quote quote)\n{\n\tt_token *token = malloc(sizeof(t_token));\n\tif (!token)\n\t\treturn (NULL);\n\t\n\ttoken->type = type;\n\ttoken->quote = quote;\n\ttoken->token_value = value ? strdup(value) : NULL;\n\ttoken->next_token = NULL;\n\treturn (token);\n}\n\n// Helper function to append token to list\nstatic void append_token(t_token **head, t_token *new_token)\n{\n\tt_token *current;\n\t\n\tif (!*head)\n\t{\n\t\t*head = new_token;\n\t\treturn;\n\t}\n\t\n\tcurrent = *head;\n\twhile (current->next_token)\n\t\tcurrent = current->next_token;\n\tcurrent->next_token = new_token;\n}\n\n// Check if character is a metacharacter in bash\nstatic int is_metachar(char c)\n{\n\treturn (c == '|' || c == '&' || c == ';' || c == '(' || c == ')' || \n\t\t\tc == '<' || c == '>' || c == ' ' || c == '\\t' || c == '\\n');\n}\n\n// Skip whitespace (space and tab)\nstatic char *skip_whitespace(char *input)\n{\n\twhile (*input == ' ' || *input == '\\t')\n\t\tinput++;\n\treturn (input);\n}\n\n// Parse operator tokens\nstatic char *parse_operator(char *input, t_token **tokens)\n{\n\tif (strncmp(input, \"&&\", 2) == 0)\n\t{\n\t\tappend_token(tokens, create_token(TOKEN_AND, \"&&\", NA));\n\t\treturn (input + 2);\n\t}\n\telse if (strncmp(input, \"||\", 2) == 0)\n\t{\n\t\tappend_token(tokens, create_token(TOKEN_OR, \"||\", NA));\n\t\treturn (input + 2);\n\t}\n\telse if (strncmp(input, \"<<\", 2) == 0)\n\t{\n\t\tappend_token(tokens, create_token(TOKEN_HEREDOC, \"<<\", NA));\n\t\treturn (input + 2);\n\t}\n\telse if (strncmp(input, \">>\", 2) == 0)\n\t{\n\t\tappend_token(tokens, create_token(TOKEN_APPEND, \">>\", NA));\n\t\treturn (input + 2);\n\t}\n\telse if (*input == '|')\n\t{\n\t\tappend_token(tokens, create_token(TOKEN_PIPE, \"|\", NA));\n\t\treturn (input + 1);\n\t}\n\telse if (*input == '<')\n\t{\n\t\tappend_token(tokens, create_token(TOKEN_REDIRECT_IN, \"<\", NA));\n\t\treturn (input + 1);\n\t}\n\telse if (*input == '>')\n\t{\n\t\tappend_token(tokens, create_token(TOKEN_REDIRECT_OUT, \">\", NA));\n\t\treturn (input + 1);\n\t}\n\telse if (*input == ';')\n\t{\n\t\tappend_token(tokens, create_token(TOKEN_SEMICOLON, \";\", NA));\n\t\treturn (input + 1);\n\t}\n\telse if (*input == '(')\n\t{\n\t\tappend_token(tokens, create_token(TOKEN_LPAREN, \"(\", NA));\n\t\treturn (input + 1);\n\t}\n\telse if (*input == ')')\n\t{\n\t\tappend_token(tokens, create_token(TOKEN_RPAREN, \")\", NA));\n\t\treturn (input + 1);\n\t}\n\telse if (*input == '&')\n\t{\n\t\tappend_token(tokens, create_token(TOKEN_AMPERSAND, \"&\", NA));\n\t\treturn (input + 1);\n\t}\n\telse if (*input == '\\n')\n\t{\n\t\tappend_token(tokens, create_token(TOKEN_NEWLINE, \"\\n\", NA));\n\t\treturn (input + 1);\n\t}\n\treturn (input);\n}\n\n// Handle single quoted strings\nstatic char *parse_single_quote(char *input, char **word, int *len, int *capacity)\n{\n\tinput++; // skip opening quote\n\t\n\twhile (*input && *input != '\\'')\n\t{\n\t\tif (*len >= *capacity - 1)\n\t\t{\n\t\t\t*capacity *= 2;\n\t\t\t*word = realloc(*word, *capacity);\n\t\t}\n\t\t(*word)[(*len)++] = *input++;\n\t}\n\t\n\tif (*input == '\\'')\n\t\tinput++; // skip closing quote\n\t\n\treturn (input);\n}\n\n// Handle double quoted strings with variable expansion and escape sequences\nstatic char *parse_double_quote(char *input, char **word, int *len, int *capacity)\n{\n\tinput++; // skip opening quote\n\t\n\twhile (*input && *input != '\"')\n\t{\n\t\tif (*len >= *capacity - 1)\n\t\t{\n\t\t\t*capacity *= 2;\n\t\t\t*word = realloc(*word, *capacity);\n\t\t}\n\t\t\n\t\tif (*input == '\\\\' && *(input + 1))\n\t\t{\n\t\t\tinput++; // skip backslash\n\t\t\t// Handle escape sequences in double quotes\n\t\t\tswitch (*input)\n\t\t\t{\n\t\t\t\tcase '\"':\n\t\t\t\tcase '\\\\':\n\t\t\t\tcase '$':\n\t\t\t\tcase '`':\n\t\t\t\tcase '\\n':\n\t\t\t\t\t(*word)[(*len)++] = *input;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t(*word)[(*len)++] = '\\\\';\n\t\t\t\t\t(*word)[(*len)++] = *input;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinput++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t(*word)[(*len)++] = *input++;\n\t\t}\n\t}\n\t\n\tif (*input == '\"')\n\t\tinput++; // skip closing quote\n\t\n\treturn (input);\n}\n\n// Parse word tokens (including quoted strings)\nstatic char *parse_word(char *input, t_token **tokens)\n{\n\tint capacity = 64;\n\tchar *word = malloc(capacity);\n\tint len = 0;\n\tt_quote quote_type = NA;\n\tint has_quotes = 0;\n\t\n\tif (!word)\n\t\treturn (input);\n\t\n\twhile (*input && !is_metachar(*input))\n\t{\n\t\tif (*input == '\\'' && quote_type != DOUBLE)\n\t\t{\n\t\t\thas_quotes = 1;\n\t\t\tif (quote_type == NA)\n\t\t\t\tquote_type = SINGLE;\n\t\t\tinput = parse_single_quote(input, &word, &len, &capacity);\n\t\t}\n\t\telse if (*input == '\"' && quote_type != SINGLE)\n\t\t{\n\t\t\thas_quotes = 1;\n\t\t\tif (quote_type == NA)\n\t\t\t\tquote_type = DOUBLE;\n\t\t\tinput = parse_double_quote(input, &word, &len, &capacity);\n\t\t}\n\t\telse if (*input == '\\\\' && quote_type == NA && *(input + 1))\n\t\t{\n\t\t\t// Handle escape sequences outside quotes\n\t\t\tif (len >= capacity - 1)\n\t\t\t{\n\t\t\t\tcapacity *= 2;\n\t\t\t\tword = realloc(word, capacity);\n\t\t\t}\n\t\t\tinput++; // skip backslash\n\t\t\tword[len++] = *input++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (len >= capacity - 1)\n\t\t\t{\n\t\t\t\tcapacity *= 2;\n\t\t\t\tword = realloc(word, capacity);\n\t\t\t}\n\t\t\tword[len++] = *input++;\n\t\t}\n\t}\n\t\n\tif (len > 0)\n\t{\n\t\tword[len] = '\\0';\n\t\t// If no quotes were encountered, reset quote_type\n\t\tif (!has_quotes)\n\t\t\tquote_type = NA;\n\t\tappend_token(tokens, create_token(TOKEN_WORD, word, quote_type));\n\t}\n\t\n\tfree(word);\n\treturn (input);\n}\n\n// Main lexer function\nt_token *ft_lexer_main(char *input)\n{\n\tt_token *tokens = NULL;\n\t\n\tif (!input)\n\t\treturn (NULL);\n\t\n\twhile (*input)\n\t{\n\t\t// Skip whitespace\n\t\tinput = skip_whitespace(input);\n\t\t\n\t\tif (!*input)\n\t\t\tbreak;\n\t\t\n\t\t// Try to parse operators first\n\t\tchar *prev_input = input;\n\t\tinput = parse_operator(input, &tokens);\n\t\t\n\t\t// If no operator was parsed, parse as word\n\t\tif (input == prev_input)\n\t\t{\n\t\t\tinput = parse_word(input, &tokens);\n\t\t}\n\t}\n\t\n\t// Add EOF token\n\tappend_token(&tokens, create_token(TOKEN_EOF, NULL, NA));\n\t\n\treturn (tokens);\n}\n\n// Helper function to free token list\n// void free_tokens(t_token *tokens)\n// {\n// \tt_token *current;\n\t\n// \twhile (tokens)\n// \t{\n// \t\tcurrent = tokens;\n// \t\ttokens = tokens->next_token;\n// \t\tfree(current->token_value);\n// \t\tfree(current);\n// \t}\n// }\n\n// Helper function to print tokens (for debugging)\nvoid print_tokens(t_token *tokens)\n{\n\tconst char *type_names[] = {\n\t\t\"WORD\", \"PIPE\", \"REDIRECT_IN\", \"REDIRECT_OUT\", \"REDIRECT_APPEND\",\n\t\t\"REDIRECT_HEREDOC\", \"AND\", \"OR\", \"SEMICOLON\", \"LPAREN\", \"RPAREN\",\n\t\t\"AMPERSAND\", \"EOF\", \"NEWLINE\"\n\t};\n\t\n\tconst char *quote_names[] = {\"NONE\", \"SINGLE\", \"DOUBLE\"};\n\t\n\twhile (tokens)\n\t{\n\t\tprintf(\"Type: %-15s Quote: %-6s Value: [%s]\\n\",\n\t\t\t   type_names[tokens->type],\n\t\t\t   quote_names[tokens->quote],\n\t\t\t   tokens->token_value ? tokens->token_value : \"NULL\");\n\t\ttokens = tokens->next_token;\n\t}\n}\n\n// Example usage\n// #ifdef TEST_LEXER\n// int main(void)\n// {\n// \tchar *test_inputs[] = {\n// \t\t\"ls -la | grep test\",\n// \t\t\"echo \\\"hello world\\\" > file.txt\",\n// \t\t\"cat file.txt && echo 'done'\",\n// \t\t\"echo $USER || echo \\\"not found\\\"\",\n// \t\t\"(ls; pwd) | wc -l\",\n// \t\t\"echo \\\"quotes \\\\\\\"inside\\\\\\\" quotes\\\"\",\n// \t\t\"echo 'single quotes'\",\n// \t\tNULL\n// \t};\n\t\n// \tfor (int i = 0; test_inputs[i]; i++)\n// \t{\n// \t\tprintf(\"\\n=== Input: %s ===\\n\", test_inputs[i]);\n// \t\tt_token *tokens = ft_lexer_main(test_inputs[i]);\n// \t\tprint_tokens(tokens);\n// \t\tfree_tokens(tokens);\n// \t}\n\t\n// \treturn (0);\n// }\n// #endif","size_bytes":8605},"SOURCE/lexer_t1/lexer_utils.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   lexer_utils.c                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 14:01:05 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/25 14:48:30 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tft_is_space(char x)\n{\n\tif (x == ' ' || x == '\\t')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_is_single_quote(char x)\n{\n\tif (x == '\\'')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_is_double_quote(char x)\n{\n\tif (x == '\"')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_is_quote(char x)\n{\n\tif (ft_is_single_quote(x) || ft_is_double_quote(x))\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_is_redirect_char(char x)\n{\n\tif (x == '<' || x == '>')\n\t\treturn (1);\n\treturn (0);\n}\n","size_bytes":1367},"SOURCE/libft/ft_atoi.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_atoi.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello <robello-@student.42.fr>           +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/20 17:31:12 by robello-          #+#    #+#             */\n/*   Updated: 2025/07/17 17:54:10 by robello          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\n// static int\tft_check_min_max(long nbr, int sign)\n// {\n// \tif (sign == 1 && nbr > INT_MAX)\n// \t\treturn (1);\n// \tif (sign == -1 && nbr > (long)INT_MAX + 1)\n// \t\treturn (1);\n// \treturn (0);\n// }\n\nlong\tft_atoi(const char *str)\n{\n\tlong\tnbr;\n\tint\t\tsign;\n\tint\t\ti;\n\n\tnbr = 0;\n\tsign = 1;\n\ti = 0;\n\twhile ((str[i] >= 9 && str[i] <= 13) || str[i] == ' ')\n\t\ti++;\n\tif (str[i] == '-' || str[i] == '+')\n\t{\n\t\tif (str[i] == '-')\n\t\t\tsign = -1;\n\t\ti++;\n\t}\n\twhile (str[i] >= '0' && str[i] <= '9')\n\t{\n\t\tnbr = nbr * 10 + (str[i] - '0');\n\t\ti++;\n\t}\n\treturn (nbr * sign);\n}\n\n// int\tft_atoi(const char *str)\n// {\n// \tlong\ti;\n// \tint\t\tsign;\n// \tlong\tnb;\n\n// \ti = 0;\n// \tnb = 0;\n// \tsign = 1;\n// \twhile ((str[i] >= 9 && str[i] <= 13) || str[i] == 32)\n// \t\ti++;\n// \tif (str[i] == '-' || str[i] == '+')\n// \t{\n// \t\tif (str[i] == '-')\n// \t\t\tsign = -1;\n// \t\ti++;\n// \t}\n// \twhile (str[i] >= '0' && str[i] <= '9')\n// \t{\n// \t\tif (nb > (LONG_MAX - (str[i] - '0')) / 10)\n// \t\t{\n// \t\t\tif (sign == 1)\n// \t\t\t\treturn (-1);  // Return -1 for positive overflow\n// \t\t\telse\n// \t\t\t\treturn (0);   // Return 0 for negative overflow\n// \t\t}\n// \t\tnb = nb * 10 + (str[i] - '0');\n// \t\ti++;\n// \t}\n// \treturn ((int)(sign * nb));\n// }\n\n// int\tmain(void)\n// {\n// \tint\ta;\n\n// \ta = ft_atoi(\" \\n\\v\\t 90{}[]4568-087\");\n// \tprintf(\"%d\\n\", a);\n// \ta = atoi(\" \\n\\v\\t 90{}[]4568-087\");\n// \tprintf(\"%d\\n\\n\", a);\n// \ta = ft_atoi(\"  -*/+98745[]{}-=-+344984efds\");\n// \tprintf(\"%d\\n\", a);\n// \ta = atoi(\"  -*/+98745[]{}-=-+344984efds\");\n// \tprintf(\"%d\\n\\n\", a);\n// \ta = ft_atoi(\"   -987044984\");\n// \tprintf(\"%d\\n\", a);\n// \ta = atoi(\"   -987044984\");\n// \tprintf(\"%d\\n\", a);\n// \ta = ft_atoi(\"\");\n// \tprintf(\"%d\\n\", a);\n// \ta = atoi(\"\");\n// \treturn (0);\n// }\n","size_bytes":2596},"SOURCE/libft/ft_bzero.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_bzero.c                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/16 13:25:08 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/24 14:56:54 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\tft_bzero(void *s, size_t n)\n{\n\tunsigned char\t*ptr;\n\n\tptr = (unsigned char *)s;\n\twhile (n--)\n\t{\n\t\t*ptr = '\\0';\n\t\tptr++;\n\t}\n}\n\n// int\tmain(void)\n// {\n// \tchar\tstr[] = \"Zeroing n bytes of this string just for fun.\";\n// \tchar\tstr0[] = \"Zeroing n bytes of this string just because.\";\n// \tchar\tstr1[] = \"Zeroing n bytes of this string just for fun.\";\n// \tchar\tstr2[] = \"Zeroing n bytes of this string just because.\";\n// \tsize_t\tn;\n\n// \tn = 11;\n// \tprintf(\"%s\\n\", str);\n// \tft_bzero(str, n);\n// \tprintf(\"After zeroing:  %s\\n\", str);\n// \tn = 5;\n// \tprintf(\"%s\\n\", str0);\n// \tft_bzero(str0 + 15, n);\n// \tprintf(\"After zeroing:  %s\\n\\n\", str0);\n// \tn = 11;\n// \tprintf(\"%s\\n\", str1);\n// \tbzero(str1, n);\n// \tprintf(\"After zeroing:  %s\\n\", str1);\n// \tn = 5;\n// \tprintf(\"%s\\n\", str2);\n// \tbzero(str2 + 15, n);\n// \tprintf(\"After zeroing: %s\\n\", str2);\n// \treturn (0);\n// }\n","size_bytes":1776},"SOURCE/libft/ft_calloc.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_calloc.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/24 15:03:10 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/28 14:10:23 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\t*ft_calloc(size_t nmemb, size_t size)\n{\n\tunsigned char\t*new_block;\n\tsize_t\t\t\tnew_size;\n\tint\t\t\t\tc;\n\n\tc = 0;\n\tnew_size = nmemb * size;\n\tnew_block = malloc(new_size);\n\tif (!(new_block))\n\t\treturn (NULL);\n\tft_memset(new_block, c, new_size);\n\treturn (new_block);\n}\n\n// int main(void)\n// {\n// \tchar *array;\n// \tint *array_int;\n// \tsize_t a;\n// \tsize_t nmemb;\n\n// \ta = 0;\n// \tnmemb = 10;\n// \tarray = ft_calloc(nmemb, sizeof(char));\n// \tif (array == NULL)\n// \t\tprintf(\"Error!\\n\");\n// \telse\n// \t{\n// \t\twhile (a < nmemb)\n// \t\t{\n// \t\t\tprintf(\"%d \", array[a]);\n// \t\t\ta++;\n// \t\t}\n// \tprintf(\"\\n\");\n// \t}\n// \tarray_int = ft_calloc(nmemb, sizeof(int));\n// \ta = 0;\n// \tif (array_int == NULL)\n// \t\tprintf(\"Error!\\n\");\n// \telse\n// \t{\n// \t\twhile (a < nmemb)\n// \t\t{\n// \t\t\tprintf(\"%d \", array_int[a]);\n// \t\t\ta++;\n// \t\t}\n// \t\tprintf(\"\\n\");\n// \t}\n// \tfree(array);\n// \tfree(array_int);\n// \treturn (0);\n// }\n","size_bytes":1799},"SOURCE/libft/ft_isalnum.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_isalnum.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/15 12:31:22 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/24 14:55:37 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nint\tft_isalnum(int c)\n{\n\treturn ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z')\n\t\t|| (c >= 'a' && c <= 'z'));\n}\n\n// int\tmain(void)\n// {\n// \tint\taln;\n\n// \taln = ft_isalnum('y');\n// \tprintf(\"%d\\n\", aln);\n// \taln = ft_isalnum('7');\n// \tprintf(\"%d\\n\", aln);\n// \taln = ft_isalnum('%');\n// \tprintf(\"%d\\n\", aln);\n// \taln = ft_isalnum(' ');\n// \tprintf(\"%d\\n\", aln);\n// \treturn (0);\n// }\n","size_bytes":1293},"SOURCE/libft/ft_isalpha.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_isalpha.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/15 09:50:34 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/27 20:09:04 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nint\tft_isalpha(int c)\n{\n\treturn ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n}\n\n// int\tmain(void)\n// {\n// \tint\talpha;\n\n// \talpha = ft_isalpha('t');\n// \tprintf(\"%d\t\", alpha);\n// \talpha = ft_isalpha('8');\n// \tprintf(\"%d\t\", alpha);\n// \treturn (0);\n// }\n","size_bytes":1169},"SOURCE/libft/ft_isascii.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_isascii.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/15 12:38:11 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/24 14:56:45 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nint\tft_isascii(int c)\n{\n\treturn (c >= 0 && c <= 127);\n}\n\n// int\tmain(void)\n// {\n// \tint\ta;\n// \tint\tasc;\n\n// \tasc = ft_isascii('\\0');\n// \tprintf(\"%d\", asc);\n// \tasc = ft_isascii('\\t');\n// \tprintf(\"%d\", asc);\n// \tasc = ft_isascii('9');\n// \tprintf(\"%d\", asc);\n// \tasc = ft_isascii('=');\n// \tprintf(\"%d\", asc);\n// \tasc = ft_isascii('e');\n// \tprintf(\"%d\", asc);\n// \tasc = ft_isascii('~');\n// \tprintf(\"%d\", asc);\n// \tasc = ft_isascii(0xE9);\n// \tprintf(\"%d\", asc);\n// \tasc = ft_isascii('<F1>');\n// \tprintf(\"%d\", asc);\n// \tasc = ft_isascii('<E7>');\n// \tprintf(\"%d\", asc);\n// \tasc = ft_isascii('<A9>');\n// \tprintf(\"%d\", asc);\n// \ta = 0;\n// \treturn (0);\n// }\n","size_bytes":1561},"SOURCE/libft/ft_isdigit.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_isdigit.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/15 12:11:24 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/24 14:56:45 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nint\tft_isdigit(int c)\n{\n\treturn (c >= '0' && c <= '9');\n}\n\n// int\tmain(void)\n// {\n// \tint\tdigit;\n\n// \tdigit = ft_isdigit('5');\n// \tprintf(\"%d\t\", digit);\n// \tdigit = ft_isdigit('x');\n// \tprintf(\"%d\t\", digit);\n// \treturn (0);\n// }\n","size_bytes":1141},"SOURCE/libft/ft_isprint.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_isprint.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/15 13:34:44 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/24 14:56:46 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nint\tft_isprint(int c)\n{\n\treturn ((c >= ' ' && c <= '~'));\n}\n\n// int\tmain(void)\n// {\n// \tint\tpnt;\n\n// \tpnt = ft_isprint('\\a');\n// \tprintf(\"%d\", pnt);\n// \tpnt = ft_isprint('\\b');\n// \tprintf(\"%d\", pnt);\n// \tpnt = ft_isprint('\\t');\n// \tprintf(\"%d\", pnt);\n// \tpnt = ft_isprint('\\n');\n// \tprintf(\"%d\", pnt);\n// \tpnt = ft_isprint('\\v');\n// \tprintf(\"%d\", pnt);\n// \tpnt = ft_isprint('5');\n// \tprintf(\"%d\", pnt);\n// \tpnt = ft_isprint('q');\n// \tprintf(\"%d\", pnt);\n// \tpnt = ft_isprint('~');\n// \tprintf(\"%d\", pnt);\n// \tpnt = ft_isprint('T');\n// \tprintf(\"%d\", pnt);\n// \tpnt = ft_isprint(' ');\n// \tprintf(\"%d\", pnt);\n// \treturn (0);\n// }\n","size_bytes":1536},"SOURCE/libft/ft_itoa.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_itoa.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/25 14:43:33 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/28 14:16:06 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nstatic\tchar\t*ft_create_string(char *str, int nbr, int n, int len)\n{\n\tif (nbr < 0)\n\t\tnbr = -nbr;\n\tstr[len] = '\\0';\n\twhile (len > 0)\n\t{\n\t\tstr[len - 1] = nbr % 10 + '0';\n\t\tnbr /= 10;\n\t\tlen--;\n\t}\n\tif (n < 0)\n\t\tstr[0] = '-';\n\treturn (str);\n}\n\nchar\t*ft_itoa(int n)\n{\n\tint\t\tlen;\n\tint\t\tnbr;\n\tchar\t*str;\n\n\tif (n == -2147483648)\n\t\treturn (str = ft_strdup(\"-2147483648\"));\n\tif (n == 0)\n\t\treturn (str = ft_strdup(\"0\"));\n\tlen = 0;\n\tnbr = n;\n\twhile (nbr)\n\t{\n\t\tnbr /= 10;\n\t\tlen++;\n\t}\n\tif (n < 0)\n\t\tlen = len + 1;\n\tnbr = n;\n\tstr = (char *)malloc(sizeof(char) * (len + 1));\n\tif (!str)\n\t\treturn (NULL);\n\tft_create_string(str, nbr, n, len);\n\treturn (str);\n}\n\n// int main()\n// {\n// \tprintf(\"\\\"%s\\\"\\n\", ft_itoa(123));\n// \tprintf(\"\\\"%s\\\"\\n\", ft_itoa(-123));\n// \tprintf(\"\\\"%s\\\"\\n\", ft_itoa(0));\n// \tprintf(\"\\\"%s\\\"\\n\", ft_itoa(2147483647));\n// \tprintf(\"\\\"%s\\\"\\n\", ft_itoa(-2147483648));\n// \tprintf(\"\\\"%s\\\"\\n\", ft_itoa(-1456));\n// \tprintf(\"\\\"%s\\\"\\n\", ft_itoa(-4526));\n// \tprintf(\"\\\"%s\\\"\\n\", ft_itoa(0));\n// \tprintf(\"\\\"%s\\\"\\n\", ft_itoa(2147483647));\n// \tprintf(\"\\\"%s\\\"\\n\", ft_itoa(-2147483648));\n// \treturn (0);\n// }","size_bytes":2002},"SOURCE/libft/ft_lstadd_back_bonus.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_lstadd_back_bonus.c                             :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello <robello-@student.42.fr>           +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/28 18:31:15 by robello-          #+#    #+#             */\n/*   Updated: 2025/07/30 17:13:49 by robello          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\tft_lstadd_back(t_list **lst, t_list *new)\n{\n\tt_list\t*last;\n\n\tif (!lst || !new)\n\t\treturn ;\n\tif (*lst == NULL)\n\t{\n\t\t*lst = new;\n\t\treturn ;\n\t}\n\tlast = *lst;\n\twhile (last->next != NULL)\n\t\tlast = last->next;\n\tlast->next = new;\n}\n\n// int\tmain(void)\n// {\n// \t//t_list\t**lst;\n// \tt_list\t*head = NULL;\n// \tt_list\t*second = NULL;\n// \tt_list\t*third = NULL;\n// \tt_list\t*fourth = NULL;\n// \tt_list *fifth = NULL;\n// \tt_list *temp;\n// \tint\t\tcnt;\n\n// \thead = (t_list *)malloc(sizeof(t_list));\n// \tsecond = (t_list *)malloc(sizeof(t_list));\n// \tthird = (t_list *)malloc(sizeof(t_list));\n// \tfourth = (t_list *)malloc(sizeof(t_list));\n// \tif (!(head && second && third && fourth))\n// \t\treturn (1);\n// \thead->next = second;\n// \tsecond->next = third;\n// \tthird->next = fourth;\n// \tfourth->next = NULL;\n// \tcnt = 0;\n// \ttemp = head;\n// \twhile (temp)\n// \t{\n// \t\ttemp = temp->next;\n// \t\tcnt++;\n// \t}\n// \tprintf(\"Number of Nodes: %d\\n\", cnt);\n// \tfifth = (t_list *)malloc(sizeof(t_list));\n// \tif (!(fifth))\n// \t\treturn (1);\n// \tfifth->next = NULL;\n// \tft_lstadd_back(&head, fifth);\n// \ttemp = head;\n// \tcnt = 0;\n// \twhile (temp)\n// \t{\n// \t\ttemp = temp->next;\n// \t\tcnt++;\n// \t}\n// \tprintf(\"Number of Nodes after using ft_lstadd_back: %d\\n\", cnt);\n// \twhile (head)\n// \t{\n// \t\ttemp = head->next;\n// \t\tfree(head);\n// \t\thead = temp;\n// \t}\n// \treturn (0);\n// }\n","size_bytes":2248},"SOURCE/libft/ft_lstadd_front_bonus.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_lstadd_front_bonus.c                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/28 16:03:36 by robello-          #+#    #+#             */\n/*   Updated: 2024/12/03 11:29:01 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\tft_lstadd_front(t_list **lst, t_list *new)\n{\n\tif (lst != NULL && new != NULL)\n\t{\n\t\tnew->next = *lst;\n\t\t*lst = new;\n\t}\n}\n\n// int\tmain (void)\n// {\n// \tt_list\t*lst;\n// \tt_list\t*new_front;\n// \tt_list\t*second;\n// \tt_list\t*third;\n// \tt_list\t*temp;\n// \tlst = NULL;\n\n// \tnew_front = (t_list *)malloc(sizeof(t_list));\n// \tsecond = (t_list *)malloc(sizeof(t_list));\n// \tthird = (t_list *)malloc(sizeof(t_list));\n// \tif (!new_front || !second)\n// \t\treturn (1);\n// \tnew_front->content = \"first node\";\n// \tsecond->content = \"second node\";\n// \tthird->content = \"third node\";\n// \tft_lstadd_front(&lst, new_front);\n// \tft_lstadd_front(&lst, second);\n// \tft_lstadd_front(&lst, third);\n// \ttemp = lst;\n// \twhile (temp)\n// \t{\n// \t\tprintf(\"%s -> \",(char *)temp->content);\n// \t\ttemp = temp->next;\n// \t}\n// \twhile(lst)\n// \t{\n// \t\ttemp  = lst;\n// \t\tlst = lst->next;\n// \t\tfree(temp);\n// \t}\n// \tprintf(\"NULL\\n\");\n// \treturn (0);\n// }\n","size_bytes":1826},"SOURCE/libft/ft_lstclear_bonus.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_lstclear_bonus.c                                :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/12/02 21:13:05 by robello-          #+#    #+#             */\n/*   Updated: 2024/12/03 11:16:08 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\tft_lstclear(t_list **lst, void (*del)(void *))\n{\n\tt_list\t*temp;\n\n\tif (!lst || !*lst)\n\t\treturn ;\n\twhile (*lst)\n\t{\n\t\ttemp = (*lst)->next;\n\t\tdel((*lst)->content);\n\t\tfree(*lst);\n\t\t*lst = temp;\n\t}\n\t*lst = NULL;\n}\n\n// void\tft_delete_cont(void *content)\n// {\n// \tfree (content);\n// }\n// int main(void)\n// {\n// \tt_list *fir = NULL;\n// \tt_list *se = NULL;\n// \tt_list *thr = NULL;\n// \tt_list *fou = NULL;\n// \tt_list *last = NULL;\n// \tt_list *temp;\n// \tint i;\n// \tfir = (t_list *)malloc(sizeof(t_list));\n// \tse = (t_list *)malloc(sizeof(t_list));\n// \tthr = (t_list *)malloc(sizeof(t_list));\n// \tfou = (t_list *)malloc(sizeof(t_list));\n// \tlast = (t_list *)malloc(sizeof(t_list));\n// \tif (!fir || !se || !thr || !last || !fou)\n// \t{\n// \t\tprintf(\"Memory allocation failed\\n\");\n// \t\treturn (1);\n// \t}\n// \tfir->content = malloc(sizeof(int));\n// \t*((int *)fir->content) = 33;\n// \tse->content = malloc(sizeof(int));\n// \t*((int *)se->content) = 1010;\n// \tthr->content = malloc(sizeof(int));\n// \t*((int *)thr->content) = 55;\n// \tfou->content = malloc(sizeof(int));\n// \t*((int *)fou->content) = 80;\n// \tlast->content = malloc(sizeof(int));\n// \t*((int *)last->content) = 66;\n// \tfir->next = se;\n// \tse->next = thr;\n// \tthr->next = fou;\n// \tfou->next = last;\n// \tlast->next = NULL;\n// \tprintf(\"All nodes' contents:\\n\");\n// \ttemp = fir;\n// \ti = 0;\n// \twhile (temp)\n// \t{\n// \t\tprintf(\"Node %d: %d\\n\", i + 1, *((int *)temp->content));\n// \t\ttemp = temp->next;\n// \t\ti++;\n// \t}\n// \tprintf(\"\\n\");\n// \tt_list *node_to_delete_from = thr;\n// \ttemp = fir;\n// \twhile (temp->next != NULL)\n// \t{\n// \t\tif (temp->next == node_to_delete_from)\n// \t\t{\n// \t\t\ttemp->next = NULL;\n// \t\t\tbreak;\n// \t\t}\n// \t\ttemp = temp->next;\n// \t}\n// \tft_lstclear(&node_to_delete_from, ft_delete_cont);\n// \tprintf(\"Remaining nodes after deleting from a random node:\\n\");\n// \ttemp = fir;\n// \ti = 0;\n// \twhile (temp)\n// \t{\n// \t\tprintf(\"Node %d: %d\\n\", i + 1, *((int *)temp->content));\n// \t\ttemp = temp->next;\n// \t\ti++;\n// \t}\n// \tft_lstclear(&fir, ft_delete_cont);\n// \treturn 0;\n// }\n","size_bytes":2936},"SOURCE/libft/ft_lstdelone_bonus.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_lstdelone_bonus.c                               :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/12/01 19:24:11 by robello-          #+#    #+#             */\n/*   Updated: 2024/12/03 11:35:15 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\tft_lstdelone(t_list *lst, void (*del)(void *))\n{\n\tif (!lst)\n\t\treturn ;\n\tif (lst->content)\n\t\tdel(lst->content);\n\tfree(lst);\n}\n\n// void\tft_delete_content(void *content)\n// {\n// \tfree (content);\n// }\n// int main(void)\n// {\n// \tt_list *head = NULL;\n// \tt_list *fir = NULL;\n// \tt_list *se = NULL;\n// \tt_list *thr = NULL;\n// \tt_list *last = NULL;\n// \tt_list *temp;\n// \tint i;\n// \thead = (t_list *)malloc(sizeof(t_list));\n// \tfir = (t_list *)malloc(sizeof(t_list));\n// \tse = (t_list *)malloc(sizeof(t_list));\n// \tthr = (t_list *)malloc(sizeof(t_list));\n// \tlast = (t_list *)malloc(sizeof(t_list));\n// \tif (!head || !fir || !se || !thr || !last)\n// \t{\n// \t\tprintf(\"Memory allocation failed\\n\");\n// \t\treturn (1);\n// \t}\n// \thead->content = malloc(sizeof(int));\n// \t*((int *)head->content) = 22;\n// \tfir->content = malloc(sizeof(int));\n// \t*((int *)fir->content) = 33;\n// \tse->content = malloc(sizeof(int));\n// \t*((int *)se->content) = 1010;\n// \tthr->content = malloc(sizeof(int));\n// \t*((int *)thr->content) = 55;\n// \tlast->content = malloc(sizeof(int));\n// \t*((int *)last->content) = 66;\n// \thead->next = fir;\n// \tfir->next = se;\n// \tse->next = thr;\n// \tthr->next = last;\n// \tlast->next = NULL;\n// \tprintf(\"All nodes' contents:\\n\");\n// \ttemp = head;\n// \ti = 0;\n// \twhile (temp)\n// \t{\n// \t\tprintf(\"Node %d: %d\\n\", i + 1, *((int *)temp->content));\n// \t\ttemp = temp->next;\n// \t\ti++;\n// \t}\n// \tprintf(\"\\n\");\n// \ttemp = head;\n// \twhile (temp->next != NULL)\n// \t{\n// \t\tif (temp->next == se)\n// \t\t{\n// \t\t\ttemp->next = se->next;\n// \t\t\tft_lstdelone(se, ft_delete_content);\n// \t\t\tbreak;\n// \t\t}\n// \t\ttemp = temp->next;\n// \t}\n// \tprintf(\"Remaining nodes after deleting one of them:\\n\");\n// \ttemp = head;\n// \ti = 0;\n// \twhile (temp)\n// \t{\n// \t\tprintf(\"Node %d: %d\\n\", i + 1, *((int *)temp->content));\n// \t\ttemp = temp->next;\n// \t\ti++;\n// \t}\n// \twhile (head)\n// \t{\n// \t\ttemp = head->next;\n// \t\tfree(head->content);\n// \t\tfree(head);\n// \t\thead = temp;\n// \t}\n// \treturn 0;\n// }\n","size_bytes":2869},"SOURCE/libft/ft_lstiter_bonus.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_lstiter_bonus.c                                 :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/12/02 22:50:52 by robello-          #+#    #+#             */\n/*   Updated: 2024/12/03 16:18:43 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\tft_lstiter(t_list *lst, void (*f)(void *))\n{\n\tif (!lst || !f)\n\t\treturn ;\n\twhile (lst)\n\t{\n\t\tf(lst->content);\n\t\tlst = lst->next;\n\t}\n}\n\nvoid\tft_multiply_node_by(void *content)\n{\n\tint\t*value;\n\n\tvalue = (int *)content;\n\t*value *= 5;\n}\n\n// int main(void)\n// {\n// \tt_list\t*node1 = malloc(sizeof(t_list));\n// \tt_list\t*node2 = malloc(sizeof(t_list));\n// \tt_list\t*node3 = malloc(sizeof(t_list));\n// \tt_list\t*node4 = malloc(sizeof(t_list));\n// \tt_list\t*temp;\n// \tint\t\ti;\n//\n// \tint *a = malloc(sizeof(int *));\n// \tint *b = malloc(sizeof(int *));\n// \tint *c = malloc(sizeof(int));\n// \tint *d = malloc(sizeof(int));\n// \t*a = 10;\n// \t*b = 20;\n// \t*c = 30;\n// \t*d = 100;\n// \tnode1->content = a;\n// \tnode1->next = node2;\n// \tnode2->content = b;\n// \tnode2->next = node3;\n// \tnode3->content = c;\n// \tnode3->next = node4;\n// \tnode4->content = d;\n// \tnode4->next = NULL;\n// \tprintf(\"Original values:\\n\");\n// \ttemp = node1;\n// \ti = 0;\n// \twhile (temp)\n// \t{\n// \t\tprintf(\"Node %d:  %d\\n\", i + 1, *((int *)temp->content));\n// \t\ttemp = temp->next;\n// \t}\n// \tft_lstiter(node1, ft_multiply_node_by);\n// \tprintf(\"\\nValues after Iterating using (f)function:\\n\");\n// \ttemp = node1;\n// \ti = 0;\n// \twhile (temp)\n// \t{\n// \t\tprintf(\"Node %d:  %d\\n\", i + 1, *((int *)temp->content));\n// \t\ttemp = temp->next;\n// \t}\n// \tfree(a);\n// \tfree(b);\n// \tfree(c);\n// \tfree(node1);\n// \tfree(node2);\n// \tfree(node3);\n// \treturn 0;\n// }\n","size_bytes":2306},"SOURCE/libft/ft_lstlast_bonus.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_lstlast_bonus.c                                 :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/28 18:25:51 by robello-          #+#    #+#             */\n/*   Updated: 2024/12/03 20:05:40 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nt_list\t*ft_lstlast(t_list *lst)\n{\n\tif (!lst)\n\t\treturn (0);\n\twhile (lst->next)\n\t\tlst = lst->next;\n\treturn (lst);\n}\n\n// int main()\n// {\n// \tt_list *head = malloc(sizeof(t_list));\n// \tt_list *second = malloc(sizeof(t_list));\n// \tt_list *third = malloc(sizeof(t_list));\n// \tt_list *fourth = malloc(sizeof(t_list));\n// \thead->content = ft_strdup(\"First\");\n// \thead->next = second;\n// \tsecond->content = ft_strdup(\"Second\");\n// \tsecond->next = third;\n// \tthird->content = ft_strdup(\"Third\");\n// \tthird->next = fourth;\n// \tfourth->content = ft_strdup(\"Fourth\");\n// \tfourth->next = NULL;\n// \tprintf(\"Linked List: \");\n// \tt_list *current = head;\n// \twhile (current)\n// \t{\n// \t\tprintf(\"%s -> \", (char *)current->content);\n// \t\tcurrent = current->next;\n// \t}\n// \tprintf(\"NULL\\n\");\n// \tt_list *last = ft_lstlast(head);\n// \tif (last)\n// \t\tprintf(\"Last element: %s\\n\", (char *)last->content);\n// \telse\n// \t\tprintf(\"The list is empty.\\n\");\n// \twhile (head)\n// \t{\n// \t\tt_list *temp = head;\n// \t\thead = head->next;\n// \t\tfree(temp);\n// \t}\n// }\n","size_bytes":1938},"SOURCE/libft/ft_lstmap_bonus.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_lstmap_bonus.c                                  :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/12/03 11:04:47 by robello-          #+#    #+#             */\n/*   Updated: 2024/12/04 15:34:45 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nt_list\t*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))\n{\n\tt_list\t*new_list;\n\tt_list\t*new_node;\n\tvoid\t*content;\n\n\tif (!lst || !f || !del)\n\t\treturn (NULL);\n\tnew_list = NULL;\n\twhile (lst)\n\t{\n\t\tcontent = f(lst->content);\n\t\tnew_node = ft_lstnew(content);\n\t\tif (!new_node)\n\t\t{\n\t\t\tif (content)\n\t\t\t\tdel(content);\n\t\t\tft_lstclear(&new_list, del);\n\t\t\treturn (NULL);\n\t\t}\n\t\tft_lstadd_back(&new_list, new_node);\n\t\tlst = lst->next;\n\t}\n\treturn (new_list);\n}\n\n// void\t*ft_string_reverse(void *content)\n// {\n// \tsize_t\ti;\n// \tsize_t\tleng;\n// \tchar\t*new_string;\n// \tchar\t*temp_content;\n\n// \ttemp_content = (char *)content;\n// \tleng = ft_strlen(temp_content);\n// \tnew_string = (char *)malloc(sizeof(char) * (leng + 1));\n// \tif (!new_string)\n// \t\treturn (NULL);\n// \ti = 0;\n// \twhile (i < leng)\n// \t{\n// \t\tnew_string[i] = temp_content[leng - i -1];\n// \t\ti++;\n// \t}\n// \tnew_string[i] = '\\0';\n// \treturn (new_string);\n// }\n\n// void\tft_delete_content(void *content)\n// {\n// \tfree (content);\n// }\n\n// int main(void)\n// {\n// \tt_list\t*node1 = malloc(sizeof(t_list));\n// \tt_list\t*node2 = malloc(sizeof(t_list));\n// \tt_list\t*node3 = malloc(sizeof(t_list));\n// \tt_list\t*node4 = malloc(sizeof(t_list));\n// \tt_list\t*node5 = malloc(sizeof(t_list));\n// \tt_list\t*new_map;\n// \tt_list\t*temp;\n// \tint\t\ti;\n\n// \tnode1->content = ft_strdup(\"GNITAERC\");\n// \tnode1->next = node2;\n// \tnode2->content = ft_strdup(\"A\");\n// \tnode2->next = node3;\n// \tnode3->content = ft_strdup(\"WEN\");\n// \tnode3->next = node4;\n// \tnode4->content = ft_strdup(\"TSIL\");\n// \tnode4->next = node5;\n// \tnode5->content = ft_strdup(\"!!\");\n// \tnode5->next = NULL;\n// \tif (!node1 || !node2 || !node3 || !node4 || !node5)\n// \t{\n// \t\tprintf(\"Memory allocation failed\\n\");\n// \t\treturn (1);\n// \t}\n// \ttemp = node1;\n// \ti = 0;\n// \twhile(temp)\n// \t{\n// \t\tprintf(\"Content of node %d:  \\\"%s\\\"\\n\", i + 1, ((char *)temp->content));\n// \t\ttemp = temp->next;\n// \t\ti++;\n// \t}\n// \tnew_map = ft_lstmap(node1, ft_string_reverse, ft_delete_content);\n// \tprintf(\"\\nNodes' values  after using ft_lstmap:\\n\");\n// \ttemp = new_map;\n// \ti = 0;\n// \twhile (temp)\n// \t{\n// \t\tprintf(\"Node %d: \\\"%s\\\"\\n\", i + 1, ((char *)temp->content));\n// \t\ttemp = temp->next;\n// \t\ti++;\n// \t}\n\n// \tft_lstclear(&node1, ft_delete_content);\n// \tft_lstclear(&new_map, ft_delete_content);\n// \treturn 0;\n// }\n\n//\n// int main(void)\n// {\n// \tt_list *node1 = malloc(sizeof(t_list));\n// \tt_list *node2 = malloc(sizeof(t_list));\n// \tt_list *node3 = malloc(sizeof(t_list));\n// \tt_list *node4 = malloc(sizeof(t_list));\n// \tint\t\ti;\n\n// \tint *a = malloc(sizeof(int *));\n// \tint *b = malloc(sizeof(int *));\n// \tint *c = malloc(sizeof(int));\n// \tint *d = malloc(sizeof(int));\n// \t*a = 10;\n// \t*b = 20;\n// \t*c = 30;\n// \t*d = 100;\n// \tnode1->content = a;\n// \tnode1->next = node2;\n// \tnode2->content = b;\n// \tnode2->next = node3;\n// \tnode3->content = c;\n// \tnode3->next = node4;\n// \tnode4->content = d;\n// \tnode4->next = NULL;\n// \tprintf(\"Original values:\\n\");\n// \tt_list *temp = node1;\n// \ti = 0;\n// \twhile (temp)\n// \t{\n// \t\tprintf(\"Node %d:  %d\\n\", i + 1, *((int *)temp->content));\n// \t\ttemp = temp->next;\n// \t}\n// \tft_lstmap(node1, (void*)ft_multiply_node_by, ft_delete_content);\n// \tprintf(\"\\nValues after Iterating using (f)function:\\n\");\n// \ttemp = node1;\n// \ti = 0;\n// \twhile (temp)\n// \t{\n// \t\tprintf(\"Node %d:  %d\\n\", i + 1, *((int *)temp->content));\n// \t\ttemp = temp->next;\n// \t}\n// \tfree(a);\n// \tfree(b);\n// \tfree(c);\n// \tfree(node1);\n// \tfree(node2);\n// \tfree(node3);\n// \treturn 0;\n// }","size_bytes":4386},"SOURCE/libft/ft_lstnew_bonus.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_lstnew_bonus.c                                  :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/26 19:24:58 by robello-          #+#    #+#             */\n/*   Updated: 2024/12/03 11:34:05 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nt_list\t*ft_lstnew(void *content)\n{\n\tt_list\t*new_node;\n\n\tnew_node = (t_list *)malloc(sizeof(t_list));\n\tif (!new_node)\n\t\treturn (NULL);\n\tnew_node->content = content;\n\tnew_node->next = NULL;\n\treturn (new_node);\n}\n\n// int\tmain(void)\n// {\n// \tt_list\t*new_node;\n// \tt_list\t*new_new;\n\n// \tchar\t*content = \"Creating a new NODE with function ft_lstnew.\";\n// \tnew_node = ft_lstnew(content);\n// \tif (!new_node)\n// \t\treturn (1);\n// \tprintf(\"Content of the new NODE is: \\\"%s\\\"\", ((char *)new_node->content));\n// \tnew_new = ft_lstnew(\"Also another new NODE'S content\");\n// \tif (!new_new)\n// \t\treturn (1);\n// \tprintf(\"\\nContent of the new NODE is: \\\"%s\\\"\", ((char *)new_new->content));\n// \tfree(new_node);\n// \tfree(new_new);\n// \treturn (0);\n// }\n","size_bytes":1643},"SOURCE/libft/ft_lstsize_bonus.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_lstsize_bonus.c                                 :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/28 17:57:06 by robello-          #+#    #+#             */\n/*   Updated: 2024/12/03 11:25:37 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nint\tft_lstsize(t_list *lst)\n{\n\tint\tcount;\n\n\tcount = 0;\n\twhile (lst)\n\t{\n\t\tlst = lst->next;\n\t\tcount++;\n\t}\n\treturn (count);\n}\n\n// int\tmain(void)\n// {\n// \tt_list\t*head = NULL;\n// \tt_list\t*second = NULL;\n// \tt_list\t*third = NULL;\n// \tt_list\t*fourth = NULL;\n// \tint\t\tsize;\n\n// \thead = (t_list *)malloc(sizeof(t_list));\n// \tsecond = (t_list *)malloc(sizeof(t_list));\n// \tthird = (t_list *)malloc(sizeof(t_list));\n// \tfourth = (t_list *)malloc(sizeof(t_list));\n// \tif (head == NULL || second == NULL || third == NULL || fourth == NULL)\n// \t{\n// \t\tprintf(\"Memory allocation failed.\\n\");\n// \t\treturn (1);\n// \t}\n// \tthird->content = \"Third\";\n// \thead->content = \"Counting how many nodes we have in this 'list'.\";\n// \thead->next = second;\n// \tsecond->next = third;\n// \tthird->next = fourth;\n// \tfourth->next = NULL;\n// \tsize = ft_lstsize(head);\n// \tprintf(\"The size of the list 'lst' is: %d nodes.\\n\", size);\n// \tprintf(\"The content of 'head' is: %s\", (char *)head->content);\n// \tfree(head);\n// \tfree(second);\n// \tfree(third);\n// \tfree(fourth);\n// \treturn (0);\n// }\n","size_bytes":1966},"SOURCE/libft/ft_memchr.c":{"content":"/* ************************************************************************** */\r\n/*                                                                            */\r\n/*                                                        :::      ::::::::   */\r\n/*   ft_memchr.c                                        :+:      :+:    :+:   */\r\n/*                                                    +:+ +:+         +:+     */\r\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\r\n/*                                                +#+#+#+#+#+   +#+           */\r\n/*   Created: 2024/11/19 16:26:38 by robello-          #+#    #+#             */\r\n/*   Updated: 2024/11/19 16:26:38 by robello-         ###   ########.fr       */\r\n/*                                                                            */\r\n/* ************************************************************************** */\r\n\r\n#include \"libft.h\"\r\n\r\nvoid\t*ft_memchr(const void *s, int c, size_t n)\r\n{\r\n\tunsigned char\t*search;\r\n\tsize_t\t\t\tlen;\r\n\r\n\tsearch = (unsigned char *)s;\r\n\tif (n == 0)\r\n\t\treturn (NULL);\r\n\tlen = 0;\r\n\twhile (len < n)\r\n\t{\r\n\t\tif (search[len] == (unsigned char)c)\r\n\t\t\treturn (&search[len]);\r\n\t\tlen++;\r\n\t}\r\n\treturn (NULL);\r\n}\r\n\r\n// int\tmain(void)\r\n// {\r\n// \tchar\t*find;\r\n// \tchar\ts[] = \"Scanning some bytes in this string\";\r\n// \tsize_t\tn;\r\n// \tint\t\tc;\r\n\r\n// \tn = 15;\r\n// \tc = 'b';\r\n// \tfind = ft_memchr(s, c, n);\r\n// \tif (find == NULL)\r\n// \t\tprintf(\"c not found\");\r\n// \telse\r\n// \t\tprintf(\"%c found at index %ld\", c, find - s);\r\n// \treturn (0);\r\n// }\r\n","size_bytes":1542},"SOURCE/libft/ft_memcmp.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_memcmp.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/19 20:16:35 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/24 14:56:51 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nint\tft_memcmp(const void *s1, const void *s2, size_t n)\n{\n\tunsigned char\t*st1;\n\tunsigned char\t*st2;\n\n\tst1 = (unsigned char *)s1;\n\tst2 = (unsigned char *)s2;\n\tif (n == 0)\n\t\treturn (0);\n\twhile (n--)\n\t{\n\t\tif (*st1 != *st2)\n\t\t\treturn (*st1 - *st2);\n\t\tst1++;\n\t\tst2++;\n\t}\n\treturn (0);\n}\n\n// int\tmain(void)\n// {\n// \tchar\ts1[] = \"This is Atring number one\";\n// \tchar\ts2[] = \"This is also another string, but number two\";\n// \tchar\ts3[] = \"another way to test this function\";\n// \tchar\ts4[] = \"another way\";\n// \tchar\ts5[] = {1, 2, 3, 4, 65, 6,7, 8, 9, 10, 11, 12};\n// \tchar\ts6[] = {1, 2, 3, 4, 5, 67, 8, 9, 11, 11, 12};\n// \tint\t\tdiff;\n// \tsize_t\tn;\n\n// \tn = 10;\n// \tdiff = ft_memcmp(s1, s2, n);\n// \tprintf(\"%d\\t\", diff);\n// \tdiff = memcmp(s1, s2, n);\n// \tprintf(\"%d\\n\", diff);\n// \tdiff = ft_memcmp(s3, s4, n);\n// \tprintf(\"%d\\t\", diff);\n// \tdiff = memcmp(s3, s4, n);\n// \tprintf(\"%d\\n\", diff);\n// \tdiff = ft_memcmp(s5, s6, n);\n// \tprintf(\"%d\\t\", diff);\n// \tdiff = memcmp(s5, s6, n);\n// \tprintf(\"%d\\n\", diff);\n// \treturn (0);\n// }\n","size_bytes":1929},"SOURCE/libft/ft_memcpy.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_memcpy.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/16 20:31:38 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/28 11:36:52 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\t*ft_memcpy(void *dest, const void *src, size_t n)\n{\n\tunsigned char\t\t*d;\n\tconst unsigned char\t*s;\n\tsize_t\t\t\t\ti;\n\n\tif (n == 0)\n\t\treturn (dest);\n\tif (!dest && !src)\n\t\treturn (0);\n\td = dest;\n\ts = src;\n\ti = 0;\n\twhile (n--)\n\t{\n\t\t((unsigned char *)d)[i] = ((unsigned char *)s)[i];\n\t\td++;\n\t\ts++;\n\t}\n\treturn (dest);\n}\n\n// int\tmain(void)\n// {\n// \tchar\tsrc[] = \"Copying some bytes into destination string.\";\n// \tchar\tdest[10];\n// \tchar\tsrc0[] = \"Copying some bytes into destination string.\";\n// \tchar\tdest0[10];\n// \tsize_t\tn;\n\n// \tn = 12;\n// \tft_putstr(src);\n// \tft_putstr(dest);\n// \tft_memcpy(dest, src, n);\n// \tft_putchar('\\n');\n// \tft_putstr(dest);\n// \tft_putchar('\\n');\n// \tft_putchar('\\n');\n// \tft_putchar('\\n');\n// \tft_putstr(src0);\n// \tft_putchar('\\n');\n// \tmemcpy(dest0, src0, n);\n// \tft_putstr(dest);\n// \treturn (0);\n// }\n","size_bytes":1737},"SOURCE/libft/ft_memmove.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_memmove.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello <robello-@student.42.fr>           +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/16 21:52:54 by robello-          #+#    #+#             */\n/*   Updated: 2025/02/15 20:16:18 by robello          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\t*ft_memmove(void *dest, const void *src, size_t n)\n{\n\tchar\t\t*ptr_dest;\n\tconst char\t*src_ptr;\n\tsize_t\t\tc;\n\n\tptr_dest = dest;\n\tsrc_ptr = src;\n\tc = 0;\n\tif (!dest && !src)\n\t\treturn (0);\n\tif (n == 0)\n\t\treturn (dest);\n\tif (dest > src)\n\t\twhile (n-- > 0)\n\t\t\t((unsigned char *)ptr_dest)[n] = ((unsigned char *)src_ptr)[n];\n\telse\n\t{\n\t\twhile (c < n)\n\t\t{\n\t\t\tptr_dest[c] = src_ptr[c];\n\t\t\tc++;\n\t\t}\n\t}\n\treturn (dest);\n}\n\n// int\tmain(void)\n// {\n// \tchar\tsrc[] = \"Copying some bytes into destination string.\";\n// \tchar\tdest[5];\n// \tchar\tsrc0[] = \"Copying some BYTES into destination string.\";\n// \tchar\tdest0[15];\n// \tsize_t\tn;\n\n// \tn = 20;\n// \tft_memmove(dest, src, n);\n// \tprintf(\"SOURCE: \\\"%s\\\"\\n\", src);\n// \tprintf(\"\\\"%s\\\"\\n\\n\", dest);\n// \tn = 35;\n// \tft_memmove(dest0, src0, n);\n// \tprintf(\"SOURCE: \\\"%s\\\"\\n\", src0);\n// \tprintf(\"\\\"%s\\\"\\n\", dest0);\n// \treturn (0);\n// }\n","size_bytes":1773},"SOURCE/libft/ft_memset.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_memset.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/15 19:53:35 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/24 14:57:26 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\t*ft_memset(void *s, int c, size_t n)\n{\n\tunsigned char\t*ptr;\n\tunsigned char\tpastebyte;\n\n\tptr = (unsigned char *)s;\n\tpastebyte = (unsigned char)c;\n\twhile (n--)\n\t{\n\t\t*ptr = pastebyte;\n\t\tptr++;\n\t}\n\treturn (s);\n}\n\n// int\tmain(void)\n// {\n// \tchar\tstr[] = \"Filling with n bytes a block of memory pointed to by s\";\n// \tchar\tstr0[] = \"Filling 123467891011 a block of memory pointed to by s\";\n// \t//int\t\tstr1[] = {1, 2, 3, 4, 5, 6, 7, 11, 12, 897, 45, 456, 45};\n// \t//int\t\tlen;\n// \tint\t\tc;\n// \tint\t\ta;\n// \tsize_t\tn;\n\n// \tc = 1;\n// \tn = 7;\n// \ta = 0;\n// \t//len = sizeof(str1) / sizeof(str1[0]);\n// \tft_putstr(str);\n// \tft_putchar('\\n');\n// \tft_memset(str, c, n);\n// \tft_putstr(str);\n// \tft_putchar('\\n');\n// \tft_putchar('\\n');\n// \tft_putstr(str0);\n// \tft_putchar('\\n');\n// \tft_memset(str0 + 20, c, n);\n// \tft_putstr(str0);\n// \tft_putchar('\\n');\n// \tft_putchar('\\n');\n// \t// while (a < len)\n// \t// {\n// \t// \tft_putnbr(str1[a]);\n// \t// \tft_putchar(' ');\n// \t// \ta++;\n// \t// }\n// \t// ft_putchar('\\n');\n// \t// ft_memset(str1 + 3, c, n);\n// \t// a = 0;\n// \t// while (a < len)\n// \t// {\n// \t// \tft_putnbr(str1[a]);\n// \t// \tft_putchar(' ');\n// \t// \ta++;\n// \t// }\n// \treturn (0);\n// }\n","size_bytes":2081},"SOURCE/libft/ft_putchar_fd.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/24 21:06:48 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/25 17:22:39 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\tft_putchar_fd(char c, int fd)\n{\n\twrite(fd, &c, 1);\n}\n// int\tmain(void)\n// {\n// \tchar\tletter;\n\n// \tletter = 'r';\n// \tft_putchar_fd(letter, 1);\n// \tletter = 's';\n// \tft_putchar_fd(letter, 1);\n// \tletter = '3';\n// \tft_putchar_fd(letter, 1);\n// \tletter = 'c';\n// \tft_putchar_fd(letter, 1);\n// \tletter = ' ';\n// \tft_putchar_fd(letter, 1);\n// \treturn(0);\n// }","size_bytes":1270},"SOURCE/libft/ft_putendl_fd.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/23 21:13:58 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/25 17:22:23 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\tft_putendl_fd(char *s, int fd)\n{\n\tif (s != NULL)\n\t{\n\t\tft_putstr_fd(s, fd);\n\t\tft_putchar_fd('\\n', fd);\n\t}\n}\n\n// int main()\n// {\n// char str[] = \"Using some functions in order to display nonsense, like \\\\n.\";\n\n// ft_putendl_fd(str, 1);\n// return (0);\n// }\n","size_bytes":1171},"SOURCE/libft/ft_putnbr_fd.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/23 21:11:45 by robello-          #+#    #+#             */\n/*   Updated: 2025/01/23 15:48:57 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\tft_putnbr_fd(int n, int fd)\n{\n\tif (n == -2147483648)\n\t\tft_putstr_fd(\"-2147483648\", fd);\n\telse if (n < 0)\n\t{\n\t\tft_putchar_fd('-', fd);\n\t\tft_putnbr_fd(-n, fd);\n\t}\n\telse if (n >= 10)\n\t{\n\t\tft_putnbr_fd(n / 10, fd);\n\t\tft_putchar_fd(n % 10 + '0', fd);\n\t}\n\telse\n\t\tft_putchar_fd(n + '0', fd);\n}\n\n// int main()\n// {\n// \tint nmb = -2147483648;\n// \tft_putnbr_fd(nmb, 1);\n// \treturn (0);\n// }\n","size_bytes":1298},"SOURCE/libft/ft_putstr_fd.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello <robello-@student.42.fr>           +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/23 21:07:53 by robello-          #+#    #+#             */\n/*   Updated: 2025/07/18 01:17:37 by robello          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\tft_putstr_fd(const char *s, int fd)\n{\n\tint\ti;\n\n\tif (s != NULL)\n\t{\n\t\ti = 0;\n\t\twhile (s[i])\n\t\t{\n\t\t\tft_putchar_fd(s[i], fd);\n\t\t\ti++;\n\t\t}\n\t}\n}\n\n// int\tmain(void)\n// {\n// \tchar\tstring[] = \"Display this string using fd in function, etc.\\n\";\n// \tchar\tstring1[] = \"\";\n// \tchar\tstring11[] = \"\\n\";\n// \tchar\tstring2[] = \"12345780987654\\n\";\n// \tchar\tstring3[] = \"\\nEnd Of the line 12365.\\n\";\n\n// \tft_putstr_fd(string, 1);\n// \tft_putstr_fd(string1, 1);\n// \tft_putstr_fd(string11, 1);\n// \tft_putstr_fd(string2, 1);\n// \tft_putstr_fd(string3, 1);\n// \treturn (0);\n// }\n","size_bytes":1469},"SOURCE/libft/ft_split.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_split.c                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/23 18:43:46 by robello-          #+#    #+#             */\n/*   Updated: 2024/12/11 23:15:24 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nstatic int\tft_count_words(const char *s, char c)\n{\n\tint\twords;\n\n\twords = 0;\n\twhile (*s)\n\t{\n\t\twhile (*s == c)\n\t\t\ts++;\n\t\tif (*s != '\\0')\n\t\t{\n\t\t\twords++;\n\t\t\twhile (*s != '\\0' && *s != c)\n\t\t\t\ts++;\n\t\t}\n\t}\n\treturn (words);\n}\n\nstatic void\tft_free_strings(char **new_strings)\n{\n\tint\ti;\n\n\ti = 0;\n\twhile (new_strings[i])\n\t{\n\t\tfree(new_strings[i]);\n\t\ti++;\n\t}\n\tfree(new_strings);\n}\n\nstatic char\t*ft_create_string(const char *s, char c)\n{\n\tint\t\tlen_word;\n\tchar\t*new_string;\n\tint\t\ti;\n\n\tlen_word = 0;\n\twhile (s[len_word] && s[len_word] != c)\n\t\tlen_word++;\n\tnew_string = (char *)malloc(sizeof(char) * (len_word + 1));\n\tif (!new_string)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (i < len_word)\n\t{\n\t\tnew_string[i] = s[i];\n\t\ti ++;\n\t}\n\tnew_string[len_word] = '\\0';\n\treturn (new_string);\n}\n\nstatic int\tft_allocate_words(const char *s, char **new_strings, char c)\n{\n\tint\tst_cnt;\n\n\tst_cnt = 0;\n\twhile (*s)\n\t{\n\t\tif (*s != c)\n\t\t{\n\t\t\tnew_strings[st_cnt] = ft_create_string(s, c);\n\t\t\tif (!new_strings[st_cnt])\n\t\t\t{\n\t\t\t\tft_free_strings(new_strings);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tst_cnt++;\n\t\t\twhile (*s && *s != c)\n\t\t\t\ts++;\n\t\t}\n\t\telse\n\t\t\ts++;\n\t}\n\treturn (st_cnt);\n}\n\nchar\t**ft_split(const char *s, char c)\n{\n\tint\t\twords;\n\tint\t\ti;\n\tchar\t**new_strings;\n\n\tif (!s)\n\t\treturn (NULL);\n\twords = ft_count_words(s, c);\n\tnew_strings = (char **) malloc (sizeof(char *) * (words + 1));\n\tif (!new_strings)\n\t\treturn (NULL);\n\ti = ft_allocate_words(s, new_strings, c);\n\tif (i == -1)\n\t\treturn (NULL);\n\tnew_strings[i] = 0;\n\treturn (new_strings);\n}\n\n// int\tmain(void)\n// {\n// \tchar\tstring[] = \"  Hello there, this is  a  splitted string    test.  \";\n// \tchar\tc;\n// \tchar\t**splitted;\n// \tint\t\ti;\n\n// \tc = ' ';\n// \tprintf(\"\\n\\\"%s\\\"\\n\", string);\n// \tsplitted = ft_split(string, c);\n// \ti = 0;\n// \twhile (splitted[i])\n// \t{\n// \t\tprintf(\"Word %d: \\\"%s\\\"\\n\", i + 1, splitted[i]);\n// \t\tfree(splitted[i]);\n// \t\ti++;\n// \t}\n// \tfree(splitted);\n// \treturn (0);\n// }\n","size_bytes":2804},"SOURCE/libft/ft_strcat.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_strcat.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello <robello-@student.42.fr>           +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/06 22:12:15 by robello           #+#    #+#             */\n/*   Updated: 2025/08/06 22:22:56 by robello          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nchar\t*ft_strcat(char *dst, const char *src)\n{\n\tsize_t\tdst_len;\n\tsize_t\ti;\n\n\tdst_len = 0;\n\ti = 0;\n\twhile (dst[dst_len] != '\\0')\n\t\tdst_len++;\n\twhile (src[i] != '\\0')\n\t{\n\t\tdst[dst_len + i] = src[i];\n\t\ti++;\n\t}\n\tdst[dst_len + i] = '\\0';\n\treturn (dst);\n}\n","size_bytes":1161},"SOURCE/libft/ft_strchr.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_strchr.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/18 13:16:41 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/28 15:02:03 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nchar\t*ft_strchr(const char *s, int c)\n{\n\tc = c % 256;\n\twhile (*s)\n\t{\n\t\tif (*s == (unsigned char)c)\n\t\t\treturn ((char *)s);\n\t\ts++;\n\t}\n\tif (c == '\\0')\n\t\treturn ((char *)s);\n\treturn (NULL);\n}\n\n// int\tmain(void)\n// {\n// \tchar\ts[] = \"Looking for character X within the string\";\n// \tchar\tempty[] = \"\";\n// \tchar\t*found;\n// \tint\t\tc;\n\n// \tc = 'X';\n// \tfound = ft_strchr(s, c);\n// \tif (found == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"%c found at index %ld\\n\", c, found - s);\n// \tc = 1024;\n// \tfound = ft_strchr(s, c);\n// \tif (found == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"%c found at index %ld\\n\", c, found - s);\n// \tc = 'l';\n// \tfound = ft_strchr(s, c);\n// \tif (found == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"%c found at index %ld\\n\", c, found - s);\n// \tc = '\\0';\n// \tfound = ft_strchr(empty, c);\n// \tif (found == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"Null Terminator %c found at index %ld\\n\", c, found - empty);\n// \tc = '\\0';\n// \tfound = ft_strchr(s, c);\n// \tif (found == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"Null Terminator %c found at index %ld\\n\", c, found - s);\n// \treturn (0);\n// }\n","size_bytes":2111},"SOURCE/libft/ft_strcmp.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_strcmp.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello <robello-@student.42.fr>           +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/06/20 16:08:24 by robello           #+#    #+#             */\n/*   Updated: 2025/06/20 16:20:53 by robello          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\nint\tft_strcmp(const char *s1, const char *s2)\n{\n\tint\ti;\n\n\ti = 0;\n\twhile (s1[i] && s2[i])\n\t{\n\t\tif (s1[i] != s2[i])\n\t\t\treturn ((unsigned char)s1[i] - (unsigned char)s2[i]);\n\t\ti++;\n\t}\n\treturn ((unsigned char)s1[i] - (unsigned char)s2[i]);\n}\n","size_bytes":1130},"SOURCE/libft/ft_strcpy.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_strcpy.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello <robello-@student.42.fr>           +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/06 22:06:11 by robello           #+#    #+#             */\n/*   Updated: 2025/08/08 01:13:30 by robello          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nchar\t*ft_strcpy(char *dst, const char *src)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\twhile (src[i] != '\\0')\n\t{\n\t\tdst[i] = src[i];\n\t\ti++;\n\t}\n\tdst[i] = '\\0';\n\treturn (dst);\n}\n","size_bytes":1067},"SOURCE/libft/ft_strdup.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_strdup.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello <robello-@student.42.fr>           +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/20 22:17:11 by robello-          #+#    #+#             */\n/*   Updated: 2025/08/06 01:34:50 by robello          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nchar\t*ft_strdup(const char *src)\n{\n\tint\t\tsize;\n\tint\t\tc;\n\tchar\t*dup;\n\n\tsize = 0;\n\twhile (src[size])\n\t\tsize++;\n\tdup = (char *)malloc(size + 1);\n\tif (dup == NULL)\n\t\treturn (NULL);\n\tc = 0;\n\twhile (src[c] != '\\0')\n\t{\n\t\tdup[c] = src[c];\n\t\tc++;\n\t}\n\tdup[c] = '\\0';\n\treturn (dup);\n}\n\n// int\tmain(void)\n// {\n// \tchar\tarray[] = \"duplicating a string using malloc and stuff\";\n// \tchar\t*dup;\n\n// \tdup = ft_strdup(array);\n// \tprintf(\"Original:  %s\\n\", array);\n// \tprintf(\"Duplicate: %s\", dup);\n// \tfree (dup);\n// \treturn (0);\n// }\n","size_bytes":1429},"SOURCE/libft/ft_striteri.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_striteri.c                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/26 18:54:02 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/30 23:58:26 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nvoid\tft_decode_helper(unsigned int a, char *s)\n{\n\tif (a % 3 == 0)\n\t\t*s = ' ';\n\tif (*s >= 'a' && *s <= 'z')\n\t\t*s -= 32;\n}\n\nvoid\tft_striteri(char *s, void (*f)(unsigned int, char*))\n{\n\tint\ta;\n\n\tif (s == 0 || f == 0)\n\t\treturn ;\n\ta = 0;\n\twhile (s[a] != '\\0')\n\t{\n\t\tf(a, &s[a]);\n\t\ta++;\n\t}\n}\n\n// int\tmain(void)\n// {\n// \tchar\tstring[] = \"Modifying the string, now it is clear!\";\n// \tprintf(\"Original: \\\"%s\\\"\\n\", string);\n// \tft_striteri(string, ft_decode_helper);\n// \tprintf(\"After using 'ft_striteri': \\\"%s\\\"\", string);\n// \treturn (0);\n// }\n","size_bytes":1446},"SOURCE/libft/ft_strjoin.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_strjoin.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello <robello-@student.42.fr>           +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/22 15:09:48 by robello-          #+#    #+#             */\n/*   Updated: 2025/03/30 17:39:51 by robello          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nchar\t*ft_strjoin(char const *s1, char const *s2)\n{\n\tchar\t*join;\n\tsize_t\ta;\n\tsize_t\tb;\n\n\tif (!s1)\n\t\ts1 = \"\";\n\tif (!s2)\n\t\ts2 = \"\";\n\tjoin = ((char *)malloc(sizeof(char) * (ft_strlen(s1) + ft_strlen(s2) + 1)));\n\tif (join == NULL)\n\t\treturn (NULL);\n\ta = 0;\n\tb = 0;\n\twhile (s1[a])\n\t{\n\t\tjoin[a] = s1[a];\n\t\ta++;\n\t}\n\twhile (s2[b])\n\t{\n\t\tjoin[a + b] = s2[b];\n\t\tb++;\n\t}\n\tjoin[a + b] = '\\0';\n\treturn (join);\n}\n\n// int\tmain(void)\n// {\n// \tchar\ts1[] = \"Creating a new string \";\n// \tchar\ts2[] = \"out of two strings, s1 and s2, looking nice!\";\n// \tchar\t*join;\n\n// \tprintf(\"\\\"%s\\\"\\n\\\"%s\\\"\\n\", s1, s2);\n// \tjoin = ft_strjoin(s1, s2);\n// \tprintf(\"\\n\\\"%s\\\"\", join);\n// \tfree(join);\n// \treturn (0);\n// }\n","size_bytes":1593},"SOURCE/libft/ft_strlcat.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_strlcat.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/17 16:09:45 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/24 14:59:08 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nsize_t\tft_strlcat(char *dest, const char *src, size_t size)\n{\n\tsize_t\ti;\n\tsize_t\tds_len;\n\tsize_t\tsr_len;\n\n\tds_len = 0;\n\twhile (dest[ds_len])\n\t\tds_len++;\n\tsr_len = 0;\n\twhile (src[sr_len])\n\t\tsr_len++;\n\ti = 0;\n\tif (size <= ds_len)\n\t\treturn (size + sr_len);\n\twhile (src[i] && (ds_len + i) < (size - 1))\n\t{\n\t\tdest[ds_len + i] = src[i];\n\t\ti++;\n\t}\n\tdest[ds_len + i] = '\\0';\n\treturn (ds_len + sr_len);\n}\n\n//int main(void)\n// {\n// \tchar\tsrc[] = \" /has been appended.\";\n// \tchar\tdest[23] = \"Something\";\n// \tchar\tsrc1[] = \"/there is enough memory space\";\n// \tchar\tdest1[50] = \"what happens when \";\n// \tchar\tsrc2[] = \"\";\n// \tchar\tdest2[21] = \"nothing appended\";\n// \tchar\tsrc3[] = \"/good timing\";\n// \tchar\tdest3[12] = \"Is it\";\n// \tchar\tsrc4[50] = \"/too long?\";\n// \tchar\tdest4[50] = \"is it \";\n// \tchar\tsrc5[] = \" /short?\";\n// \tchar\tdest5[24] = \"or perhaps too\";\n// \tprintf(\"%zu \", ft_strlcat(dest, src, sizeof(dest)));\n// \tprintf(\"%s\\n\", dest);\n// \tprintf(\"%zu \", ft_strlcat(dest1, src1, sizeof(dest1)));\n// \tprintf(\"%s\\n\", dest1);\n// \tprintf(\"%zu \", ft_strlcat(dest2, src2, sizeof(dest2)));\n// \tprintf(\"%s\\n\", dest2);\n// \tprintf(\"%zu \", ft_strlcat(dest3, src3, sizeof(dest3)));\n// \tprintf(\"%s\\n\", dest3);\n// \tprintf(\"%zu \", ft_strlcat(dest4, src4, sizeof(dest4)));\n// \tprintf(\"%s\\n\", dest4);\n// \tprintf(\"%zu \", ft_strlcat(dest5, src5, sizeof(dest5)));\n// \tprintf(\"%s\\n\", dest5);\n// \treturn (0);\n// }","size_bytes":2298},"SOURCE/libft/ft_strlcpy.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_strlcpy.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/16 23:57:31 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/27 20:09:03 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nsize_t\tft_strlcpy(char *dest, const char *src, size_t size)\n{\n\tsize_t\ti;\n\tsize_t\tsrc_len;\n\n\tsrc_len = 0;\n\twhile (src[src_len] != '\\0')\n\t\tsrc_len++;\n\tif (size == 0)\n\t\treturn (src_len);\n\ti = 0;\n\twhile (i < size - 1 && src[i] != '\\0')\n\t{\n\t\tdest[i] = src[i];\n\t\ti++;\n\t}\n\tdest[i] = '\\0';\n\treturn (src_len);\n}\n\n// int\tmain(void)\n// {\n// \tchar\tsrc[] = {\"Learning C will eventually make sense\"};\n// \tchar\tdest[5];\n// \tchar\tsrc1[] = \"Oooyys s11hf1\";\n// \tchar\tdest1[16];\n// \tchar\tsrc2[] = \"changing to blocksF SaF Adds/D\";\n// \tchar\tdest2[8];\n// \tchar\tsrc3[] = \"\";\n// \tchar\tdest3[10];\n// \tchar\tsrc4[] = \"?_ lowercase 67!\";\n// \tchar\tdest4[30];\n// \tchar\tsrc5[] = \"function strlcpy() in action\";\n// \tchar\tdest5[3];\n\n// \tprintf(\"%zu \", ft_strlcpy(dest, src, sizeof(dest)));\n// \tprintf(\"%s\\n\", dest);\n// \tprintf(\"%zu \", ft_strlcpy(dest1, src1, sizeof(dest1)));\n// \tprintf(\"%s\\n\", dest1);\n// \tprintf(\"%zu \", ft_strlcpy(dest2, src2, sizeof(dest2)));\n// \tprintf(\"%s\\n\", dest2);\n// \tprintf(\"%zu \", ft_strlcpy(dest3, src3, sizeof(dest3)));\n// \tprintf(\"%s\\n\", dest3);\n// \tprintf(\"%zu \", ft_strlcpy(dest4, src4, sizeof(dest4)));\n// \tprintf(\"%s\\n\", dest4);\n// \tprintf(\"%zu \", ft_strlcpy(dest5, src5, sizeof(dest5)));\n// \tprintf(\"%s\\n\", dest5);\n// \treturn (0);\n// }\n","size_bytes":2152},"SOURCE/libft/ft_strlen.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_strlen.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/15 13:42:10 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/24 14:59:22 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nsize_t\tft_strlen(const char *s)\n{\n\tsize_t\tlen;\n\n\tlen = 0;\n\twhile (s[len])\n\t\tlen++;\n\treturn (len);\n}\n\n// int\tmain(void)\n// {\n// \tsize_t\tlen;\n\n// \tlen = ft_strlen(\"Calculates size of an array, excluding null terminator\");\n// \tprintf(\"%zu\", len);\n// \treturn (0);\n// }\n","size_bytes":1177},"SOURCE/libft/ft_strmapi.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_strmapi.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/25 14:44:18 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/28 11:19:26 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nchar\tft_strmapi_helper(unsigned int c, char l)\n{\n\tif (l == 'e')\n\t\treturn ('3');\n\tif (c % 3 == 0)\n\t\tl += 15;\n\tif (l >= 65 && l <= 90)\n\t\tl += 32;\n\tif (l == 'a')\n\t\tl -= 32;\n\treturn (l);\n}\n\nchar\t*ft_strmapi(char const *s, char (*f)(unsigned int, char))\n{\n\tunsigned int\tc;\n\tchar\t\t\t*create;\n\n\tif (!s || !f)\n\t\treturn (NULL);\n\tcreate = (char *)malloc(sizeof(char) * (ft_strlen(s) + 1));\n\tif (!create)\n\t\treturn (NULL);\n\tc = 0;\n\twhile (s[c] != '\\0')\n\t{\n\t\tcreate[c] = f(c, s[c]);\n\t\tc++;\n\t}\n\tcreate[c] = '\\0';\n\treturn (create);\n}\n\n// int main(void)\n// {\n// \tchar string[] = \"What Can Be done To Alter Its Indices Using Another f?\";\n// \tchar *string_mod;\n\n// \tprintf(\"Original string: %s\\n\", string);\n// \tstring_mod = ft_strmapi(string, ft_strmapi_helper);\n// \tif (string_mod)\n// \t{\n// \t\tprintf(\"Modified string: %s\\n\", string_mod);\n// \t\tfree(string_mod);\n// \t}\n// \telse\n// \tprintf(\"Memory allocation failed.\\n\");\n// \treturn (0);\n// }\n","size_bytes":1834},"SOURCE/libft/ft_strncmp.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_strncmp.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/18 18:23:37 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/24 14:59:30 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nint\tft_strncmp(const char *s1, const char *s2, size_t n)\n{\n\tsize_t\tw;\n\n\tw = 0;\n\twhile (w < n && s1[w] && s2[w])\n\t{\n\t\tif (s1[w] != s2[w])\n\t\t\treturn ((unsigned char)s1[w] - (unsigned char)s2[w]);\n\t\tw++;\n\t}\n\tif (w < n)\n\t\treturn ((unsigned char)s1[w] - (unsigned char)s2[w]);\n\treturn (0);\n}\n\n// int\tmain(void)\n// {\n// \tchar\tstring[] = \"I wannA compare the content \";\n// \tchar\tstring1[] = \"I wanna compare the content \";\n// \tchar\tstring2[] = \"I wanted to compare 3THE3 content \";\n// \tchar\tstring3[] = \"I wanted to compare the content \";\n// \tchar\tstring4[] = \"I wannA to compare the content \";\n// \tchar\tstring5[] = \"I wannA To \";\n// \tchar\tstring6[] = \"I wanted to compare the content \";\n// \tchar\tstring7[] = \"I wanted to compare the content \";\n// \tsize_t\tn;\n// \tint\t\tdiff;\n\n// \tn = 17;\n// \tdiff = ft_strncmp(string, string1, n);\n// \tprintf(\"%d\\n\", diff);\n// \tdiff = ft_strncmp(string2, string3, n);\n// \tprintf(\"%d\\n\", diff);\n// \tdiff = ft_strncmp(string4, string5, n);\n// \tprintf(\"%d\\n\", diff);\n// \tdiff = ft_strncmp(string6, string7, n);\n// \tprintf(\"%d\\n\", diff);\n// \treturn (0);\n// }\n","size_bytes":1992},"SOURCE/libft/ft_strnstr.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_strnstr.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/19 21:20:42 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/28 13:44:16 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nchar\t*ft_strnstr(const char *big, const char *little, size_t len)\n{\n\tsize_t\ti;\n\tsize_t\tj;\n\n\tif (little[0] == '\\0')\n\t\treturn ((char *)big);\n\ti = 0;\n\twhile (big[i] != '\\0')\n\t{\n\t\tj = 0;\n\t\twhile (big[i + j] == little[j] && (i + j) < len)\n\t\t{\n\t\t\tif (big[i + j] == '\\0' && little[j] == '\\0')\n\t\t\t\treturn ((char *)&big[i]);\n\t\t\tj++;\n\t\t}\n\t\tif (little[j] == '\\0')\n\t\t\treturn ((char *)big + i);\n\t\ti++;\n\t}\n\treturn (NULL);\n}\n\n// int\tmain(void)\n// {\n// \tchar\t*res;\n// \tsize_t\tlen;\n// \tchar\tbig[] = \"Another test for this function\";\n// \tchar\tlittle[] = \"\";\n// \tchar\tbig1[] = \"Another test for this. function\";\n// \tchar\tlittle1[] = \"this.\";\n// \tchar\tbig2[] = \"Did we get the NULL?\";\n// \tchar\tlittle2[] = \"1234567789900\";\n// \tchar\tbig3[] = \"o\";\n// \tchar\tlittle3[] = \"\";\n// \tchar\tbig4[] = \"this time it seems to be the same but...\";\n// \tchar\tlittle4[] = \"this time it seems to be the same but\";\n// \tchar\tbig5[] = \"Hello people of the world\";\n// \tchar\tlittle5[] = \"people\";\n// \tchar\tbig6[] = \"The quick brown fox jumps over the lazy dog\";\n// \tchar\tlittle6[] = \"fox jumps\";\n// \tchar\tbig7[] =\"Short\";\n// \tchar\tlittle7[] = \"Longer Short Substring\";\n\n// \tlen = 31;\n// \tres = ft_strnstr(big, little, len);\n// \tif (res == big)\n// \t\tprintf(\"Little is Empty. Big: \\\"%s\\\"\\n\\n\", res);\n// \telse if (res != NULL)\n// \t\tprintf(\"Found: \\\"%s\\\"\\n\\n\", res);\n// \telse\n// \t\tprintf(\"Substring not found.\\n\\n\");\n// \tlen = 35;\n// \tres = ft_strnstr(big1, little1, len);\n// \tif (res == big1)\n// \t\tprintf(\"Little is Empty. Big: \\\"%s\\\"\\n\\n\", res);\n// \telse if (res)\n// \t\tprintf(\"Found: \\\"%s\\\"\\n\\n\", res);\n// \telse\n// \t\tprintf(\"Substring not found.\\n\\n\");\n// \tlen = 0;\n// \tres = ft_strnstr(big2, little2, len);\n// \tif (res == big2)\n// \t\tprintf(\"Little is Empty. Big: \\\"%s\\\"\\n\\n\", res);\n// \telse if (res)\n// \t\tprintf(\"Found: \\\"%s\\\"\\n\\n\", res);\n// \telse\n// \t\tprintf(\"Substring not found.\\n\\n\");\n// \tlen = 100;\n// \tres = ft_strnstr(big3, little3, len);\n// \tif (res == big3)\n// \t\tprintf(\"Little is Empty. Big: \\\"%s\\\"\\n\\n\", res);\n// \telse if (res)\n// \t\tprintf(\"Found: \\\"%s\\\"\\n\\n\", res);\n// \telse\n// \t\tprintf(\"Substring not found.\\n\\n\");\n// \tlen = 30;\n// \tres = ft_strnstr(big4, little4, len);\n// \tif (res == big4)\n// \t\tprintf(\"Little is Empty. Big: \\\"%s\\\"\\n\\n\", res);\n// \telse if (res)\n// \t\tprintf(\"Found: \\\"%s\\\"\\n\\n\", res);\n// \telse\n// \t\tprintf(\"Substring not found.\\n\\n\");\n// \tlen = 12;\n// \tres = ft_strnstr(big5, little5, len);\n// \tif (res == big5)\n// \t\tprintf(\"Little is Empty. Big: \\\"%s\\\"\\n\\n\", res);\n// \telse if (res)\n// \t\tprintf(\"Found: \\\"%s\\\"\\n\\n\", res);\n// \telse\n// \t\tprintf(\"Substring not found.\\n\\n\");\n// \tlen = 25;\n// \tres = ft_strnstr(big6, little6, len);\n// \tif (res == big6)\n// \t\tprintf(\"Little is Empty. Big: \\\"%s\\\"\\n\\n\", res);\n// \telse if (res)\n// \t\tprintf(\"Found: \\\"%s\\\"\\n\\n\", res);\n// \telse\n// \t\tprintf(\"Substring not found.\\n\\n\");\n// \tlen = 25;\n// \tres = ft_strnstr(big7, little7, len);\n// \tif (res == big7)\n// \t\tprintf(\"Little is Empty. Big: \\\"%s\\\"\\n\\n\", res);\n// \telse if (res)\n// \t\tprintf(\"Found: \\\"%s\\\"\\n\\n\", res);\n// \telse\n// \t\tprintf(\"Substring not found.\\n\\n\");\n// \treturn (0);\n// }\n","size_bytes":3968},"SOURCE/libft/ft_strrchr.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_strrchr.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/18 15:48:01 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/30 22:24:27 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nchar\t*ft_strrchr(const char *s, int c)\n{\n\tint\tlen;\n\n\tlen = 0;\n\twhile (s[len])\n\t\tlen++;\n\twhile (len >= 0)\n\t{\n\t\tif (s[len] == (char)c)\n\t\t\treturn ((char *)(s + len));\n\t\tlen--;\n\t}\n\treturn (NULL);\n}\n\n// int\tmain(void)\n// {\n// \tchar\ts[] = \"Looking\\0X for chara\\0cter X \\0within the string\";\n// \tchar\tempty[] = \"\";\n// \tchar\t*find_last;\n// \tint\t\tc;\n\n// \tc = 'X';\n// \tfind_last = ft_strrchr(s, c);\n// \tif (find_last == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"%c found at index %ld\\n\", c, find_last - s);\n// \tc = 'r';\n// \tfind_last = ft_strrchr(s, c);\n// \tif (find_last == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"%c found at index %ld\\n\", c, find_last - s);\n// \tc = 'z';\n// \tfind_last = ft_strrchr(s, c);\n// \tif (find_last == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"%c found at index %ld\\n\", c, find_last - s);\n// \tc = '\\0';\n// \tfind_last = ft_strrchr(empty, c);\n// \tif (find_last == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"Null Terminator %c found at index %ld\\n\", c, find_last - empty);\n// \tc = '\\0';\n// \tfind_last = ft_strrchr(s, c);\n// \tif (find_last == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"Null Terminator %c found at index %ld\\n\", c, find_last - s);\n// \tprintf(\"\\n\\n\");\n// \tc = 'X';\n// \tfind_last = strrchr(s, c);\n// \tif (find_last == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"%c found at index %ld\\n\", c, find_last - s);\n// \tc = 105;\n// \tfind_last = strrchr(s, c);\n// \tif (find_last == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"%c found at index %ld\\n\", c, find_last - s);\n// \tc = 'z';\n// \tfind_last = strrchr(s, c);\n// \tif (find_last == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"%c found at index %ld\\n\", c, find_last - s);\n// \tc = '\\0';\n// \tfind_last = strrchr(empty, c);\n// \tif (find_last == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"Null Terminator %c found at index %ld\\n\", c, find_last - empty);\n// \tc = '\\0';\n// \tfind_last = strrchr(s, c);\n// \tif (find_last == NULL)\n// \t\tprintf(\"%c not found\\n\", c);\n// \telse\n// \t\tprintf(\"Null Terminator %c found at index %ld\\n\", c, find_last - s);\n// \treturn (0);\n// }\n","size_bytes":3114},"SOURCE/libft/ft_strtrim.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_strtrim.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/22 17:50:04 by robello-          #+#    #+#             */\n/*   Updated: 2024/12/20 14:32:17 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nchar\t*ft_strtrim(char const *s1, char const *set)\n{\n\tsize_t\ti;\n\tchar\t*trimmed;\n\n\tif (!s1 || !set)\n\t\treturn (0);\n\twhile (*s1 && ft_strchr(set, *s1))\n\t\ts1++;\n\ti = ft_strlen(s1);\n\twhile (i && ft_strchr(set, s1[i]))\n\t\ti--;\n\ttrimmed = ft_substr(s1, 0, i + 1);\n\treturn (trimmed);\n}\n\n// int main()\n// {\n// \tchar\ts[] = \" \\t\\n\\t\\nThis is   not a clean string.\\t  \\n\";\n// \tchar\ts1[] = \"\";\n// \tchar\ts2[] = \"123\t\t\t\t\t\";\n// \tchar\ts3[] = \" \\f\\n\\r\\v\\t \";\n// \tchar\ts4[] = \" \\t\\n\\t\\nClean string.\\t  \\n\";\n// \tchar\ts5[] = \"\tR\t\\v\";\n// \tchar\ts6[] = \"  1 2  3\t\t\";\n// \tchar\t*set = \" \\f\\n\\r\\v\\t\";\n// \tchar\t*trimmed;\n// \tchar\t*trimmed1;\n// \tchar\t*trimmed2;\n// \tchar\t*trimmed3;\n// \tchar\t*trimmed4;\n// \tchar\t*trimmed5;\n// \tchar\t*trimmed6;\n\n// \tprintf(\"Original string: \\\"%s\\\"\\n\", s);\n// \ttrimmed = ft_strtrim(s, set);\n// \tprintf(\"Trimmed string1 : \\\"%s\\\"\\n\\n\\n\", trimmed);\n// \tfree(trimmed);\n\n// \tprintf(\"Original string: \\\"%s\\\"\\n\", s1);\n// \ttrimmed1 = ft_strtrim(s1, set);\n// \tprintf(\"Trimmed string2 : \\\"%s\\\"\\n\\n\\n\", trimmed1);\n// \tfree(trimmed1);\n\n// \tprintf(\"Original string: \\\"%s\\\"\\n\", s2);\n// \ttrimmed2 = ft_strtrim(s2, set);\n// \tprintf(\"Trimmed string3 : \\\"%s\\\"\\n\\n\\n\", trimmed2);\n// \tfree(trimmed2);\n\n// \tprintf(\"Original string: \\\"%s\\\"\\n\", s3);\n// \ttrimmed3 = ft_strtrim(s3, set);\n// \tprintf(\"Trimmed string4 : \\\"%s\\\"\\n\\n\\n\", trimmed3);\n// \tfree(trimmed3);\n\n// \tprintf(\"Original string: \\\"%s\\\"\\n\", s4);\n// \ttrimmed4 = ft_strtrim(s4, set);\n// \tprintf(\"Trimmed string5 : \\\"%s\\\"\\n\\n\\n\", trimmed4);\n// \tfree(trimmed4);\n\n// \tprintf(\"Original string: \\\"%s\\\"\\n\", s5);\n// \ttrimmed5 = ft_strtrim(s5, set);\n// \tprintf(\"Trimmed string6 : \\\"%s\\\"\\n\\n\\n\", trimmed5);\n// \tfree(trimmed5);\n\n// \tprintf(\"Original string: \\\"%s\\\"\\n\", s6);\n// \ttrimmed6 = ft_strtrim(s6, set);\n// \tprintf(\"Trimmed string7 : \\\"%s\\\"\\n\\n\\n\", trimmed6);\n// \tfree(trimmed6);\n// \treturn 0;\n// }\n","size_bytes":2744},"SOURCE/libft/ft_substr.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_substr.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/21 21:50:12 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/26 15:54:06 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nchar\t*ft_substr(char const *s, unsigned int start, size_t len)\n{\n\tchar\t*subst;\n\tsize_t\ti;\n\tsize_t\tsize;\n\n\tif (s == NULL)\n\t\treturn (NULL);\n\tsize = 0;\n\twhile (s[size])\n\t\tsize++;\n\tif (start >= size)\n\t\treturn (ft_strdup(\"\"));\n\tsize = size - start;\n\tif (size > len)\n\t\tsize = len;\n\tsubst = (char *)malloc(size + 1);\n\tif (subst == NULL)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (i < size)\n\t{\n\t\tsubst[i] = s[start + i];\n\t\ti++;\n\t}\n\tsubst[i] = '\\0';\n\treturn (subst);\n}\n\n// int\tmain(void)\n// {\n// \tchar\t\t\tstring[] = \"Getting a subtring from this string.\";\n// \tchar\t\t\t*subst;\n// \tunsigned int\tstart;\n// \tsize_t\t\t\tlen;\n\n// \tstart = 10;\n// \tlen = 18;\n// \tsubst = ft_substr(string, start, len);\n// \tprintf(\"Original:\t\\\"%s\\\"\\n\", string);\n// \tprintf(\"substring:\t\\\"%s\\\"\\n\", subst);\n// \t//printf(\"starting at index: %u\", start);\n// free(subst);\n// \tstart = 40;\n// \tlen = 18;\n// \tsubst = ft_substr(string, start, len);\n// \tprintf(\"\\n\\n\");\n// \tprintf(\"Original:\t\\\"%s\\\"\\n\", string);\n// \tprintf(\"substring:\t\\\"%s\\\"\\n\", subst);\n// \t//printf(\"starting at index: %u\", start);\n// free(subst);\n// \treturn (0);\n// }\n","size_bytes":1989},"SOURCE/libft/ft_tolower.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_tolower.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/17 22:27:41 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/24 15:00:48 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nint\tft_tolower(int c)\n{\n\tif (c >= 'A' && c <= 'Z')\n\t\treturn (c + 32);\n\treturn (c);\n}\n\n// int\tmain(void)\n// {\n// \tint\tletter;\n// \tint\tletter1;\n// \tint\tletter2;\n\n// \tletter = 70;\n// \tletter1 = 100;\n// \tletter2 = 50;\n// \tprintf(\"%c\t\", letter);\n// \tletter = ft_tolower(letter);\n// \tprintf(\"%c\\n\", letter);\n// \tprintf(\"%c\t\", letter1);\n// \tletter1 = ft_tolower(letter1);\n// \tprintf(\"%c\\n\", letter1);\n// \tprintf(\"%c\t\", letter2);\n// \tletter1 = ft_tolower(letter2);\n// \tprintf(\"%c\", letter2);\n// \treturn (0);\n// }\n","size_bytes":1417},"SOURCE/libft/ft_toupper.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_toupper.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: robello- <robello-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/17 20:37:00 by robello-          #+#    #+#             */\n/*   Updated: 2024/11/24 15:01:07 by robello-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"libft.h\"\n\nint\tft_toupper(int c)\n{\n\tif (c >= 'a' && c <= 'z')\n\t\treturn (c - 32);\n\treturn (c);\n}\n\n// int\tmain(void)\n// {\n// \tint\tc;\n\n// \tc = 115;\n// \tprintf(\"%c\t\", c);\n// \tc = ft_toupper(c);\n// \tprintf(\"%c\", c);\n// \treturn (0);\n// }\n","size_bytes":1133},"SOURCE/main/build_env.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   build_env.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/21 10:53:39 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/21 11:27:22 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nt_env_var\t*ft_build_env_list(char **env_vars)\n{\n\tt_env_var\t*new_node;\n\tt_env_var\t*first;\n\tt_env_var\t*last;\n\tint\t\t\ti;\n\n\tfirst = NULL;\n\tlast = NULL;\n\ti = 0;\n\twhile (env_vars[i])\n\t{\n\t\tnew_node = ft_create_env_list(env_vars[i]);\n\t\tif (new_node)\n\t\t{\n\t\t\tif (!first)\n\t\t\t\tfirst = new_node;\n\t\t\telse\n\t\t\t\tlast->next_envar = new_node;\n\t\t\tlast = new_node;\n\t\t}\n\t\ti++;\n\t}\n\treturn (first);\n}\n","size_bytes":1303},"SOURCE/main/main.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.c                                             :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/29 19:07:32 by robello           #+#    #+#             */\n/*   Updated: 2025/09/15 12:15:27 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nt_gb g_gb = {0, 0};\n\n// Add to SOURCE/main/main.c\nint\tft_handle_parsing_error(t_token *tokens, char *input_line, t_shell *shell)\n{\n\tif (tokens)\n\t\tfree_tokens(tokens);\n\tif (input_line)\n\t\tfree(input_line);\n\tshell->last_status = 2; // Syntax error\n\treturn (0);\n}\n\n// Add to SOURCE/main/main.c\nvoid\tft_update_signal_exit_codes(t_shell *shell)\n{\n\tif (g_gb.last_sig == SIGINT)\n\t{\n\t\tshell->last_status = 130;\n\t\tg_gb.last_status_code = 130;\n\t}\n\telse if (g_gb.last_sig == SIGQUIT)\n\t{\n\t\tshell->last_status = 131;\n\t\tg_gb.last_status_code = 131;\n\t}\n}\n\nt_shell\t*ft_init_shell(void)\n{\n\tt_shell\t*shell;\n\n\tshell = malloc(sizeof(t_shell));\n\tif (!shell)\n\t\treturn (NULL);\n\tshell->env_list = NULL;\n\tshell->cmd_list = NULL;\n\tshell->array_list = NULL;\n\tshell->last_status = 0;\n\treturn (shell);\n}\n\nt_shell\t*ft_shell_setup(char **env_vars)\n{\n\tt_shell\t*shell;\n\n\tshell = ft_init_shell();\n\tif (!shell)\n\t\treturn (NULL);\n\tshell->envp = env_vars;\n\tshell->env_list = ft_build_env_list(env_vars);\n\treturn (shell);\n}\n\nint\tft_manage_inputline(char *input_line, t_shell *shell)\n{\n\tt_token\t*tokens;\n\n\tif (!input_line)\n\t\treturn (1);\n\tif (*input_line)\n\t{\n\t\tadd_history(input_line);\n\t\tshell->line_cnt++;\n\t}\n\tft_trim_newline(input_line);\n\t// Reset global status before parsing\n\tg_gb.last_status_code = 0;\n\ttokens = ft_lexer_main(input_line);\n\tif (!tokens)\n\t\treturn (free(input_line), 0);\n\t//quotes_tokens(tokens);\n\t//print_tokens(tokens);\n\tshell->cmd_list = ft_parser_main(tokens);\n\t//print_command_list(shell->cmd_list); // Debugging line to print commands\n\tfree_tokens(tokens);\n\tfree(input_line);\n\tif (!shell->cmd_list)\n\t{\n\t\t// Check if it's a redirection error (exit code 1) or syntax error (exit code 2)\n\t\tif (g_gb.last_status_code == 1)\n\t\t\tshell->last_status = 1; // Redirection error\n\t\telse\n\t\t\tshell->last_status = 2; // Syntax error\n\t\treturn (0);\n\t}\n\tft_expand_cmds(shell->cmd_list, shell);\n\tft_start_execution(shell->cmd_list, shell);\n\tft_free_commands(&shell->cmd_list);\n\treturn (0);\n}\n\nvoid\tmaster_shell_loop(t_shell *shell)\n{\n\tchar\t*prompt_line;\n\tchar\t*input_line;\n\tint loop;\n\tint is_interactive;\n\t\n\tloop = 0;\n\tis_interactive = isatty(STDIN_FILENO);\n\twhile (!loop)\n\t{\n\t\t// Reset signal before each prompt\n\t\tg_gb.last_sig = 0;\n\t\t\n\t\tif (is_interactive)\n\t\t{\n\t\t\tprompt_line = ft_build_prompt();\n\t\t\tif (!prompt_line)\n\t\t\t\tcontinue ;\n\t\t}\n\t\telse\n\t\t\tprompt_line = NULL;\n\t\t\n\t\tinput_line = read_input_with_quotes(prompt_line, \"> \");\n\t\tif (prompt_line)\n\t\t\tfree(prompt_line);\n\t\t\n\t\t// Handle SIGINT or NULL input\n\t\t\n\t\tif (g_gb.last_sig == SIGINT)\n\t\t{\n\t\t    free(input_line);\n\t\t    continue;\n\t\t}\n\t\t\n\t\t// EOF → exit shell\n\t\tif (!input_line)\n\t\t{\n\t\t\t// Only print EOF in interactive mode\n\t\t\tif (is_interactive)\n\t\t\t\tft_putstr_fd(RED \"exit\\n\" RESET, 1);\n\t\t    break;\n\t\t}\n\t\t// Process the complete input line\n\t\tloop = ft_manage_inputline(input_line, shell);\n\t\tg_gb.last_status_code = shell->last_status;\n\t\tft_update_signal_exit_codes(shell);\n\t}\n}\n\nint\tmain(int ac, char **av, char **env_vars)\n{\n\tt_shell\t*shell;\n\n\t(void)ac;\n\t(void)av;\n\tft_setup_signals();\n\t\n\tshell = ft_shell_setup(env_vars);\n\tif (!shell)\n\t\texit(EXIT_FAILURE);\n\tmaster_shell_loop(shell);\n\trl_clear_history();\n\tft_clean_shell_setup(shell);\n\treturn (g_gb.last_status_code);\n}\n","size_bytes":4120},"SOURCE/main/prompt.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   prompt.c                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/22 14:54:55 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/15 10:50:24 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nchar\t*ft_show_home(const char *cwd)\n{\n\tsize_t\tlen;\n\tchar\t*home;\n\n\thome = getenv(\"HOME\");\n\tif (!home)\n\t\treturn (ft_strdup(cwd));\n\tlen = 0;\n\twhile (home[len] && cwd[len] && home[len] == cwd[len])\n\t\tlen++;\n\tif (len > 0)\n\t\treturn (ft_strjoin(\"~\", cwd + len));\n\treturn (ft_strdup(cwd));\n}\n\nchar\t*ft_edit_hostname(const char *hostname)\n{\n\tsize_t\ti;\n\tchar\t*new_name;\n\n\tif (!hostname)\n\t\treturn (ft_strdup(\"unknown\"));\n\ti = 0;\n\twhile (hostname[i] && hostname[i] != '.')\n\t\ti++;\n\tnew_name = ft_substr(hostname, 0, i);\n\tif (!new_name)\n\t\treturn (NULL);\n\treturn (new_name);\n}\n\nchar\t*ft_prompt_userhost(const char *user, const char *hostname)\n{\n\tchar\t*joined;\n\tchar\t*host;\n\tchar\t*tmp;\n\n\thost = ft_edit_hostname(hostname);\n\tif (!host)\n\t\treturn (NULL);\n\tjoined = ft_strjoin(COLOR_USERHOST, user);\n\tif (!joined)\n\t\treturn (free(host), NULL);\n\ttmp = ft_strjoin(joined, \"@\");\n\tfree(joined);\n\tif (!tmp)\n\t\treturn (free(host), NULL);\n\tjoined = ft_strjoin(tmp, host);\n\tfree(tmp);\n\tfree(host);\n\tif (!joined)\n\t\treturn (NULL);\n\ttmp = ft_strjoin(joined, COLOR_SHELL \" minishell>\");\n\tfree(joined);\n\treturn (tmp);\n}\n\nchar\t*ft_prompt_path(char *user_host, const char *cwd)\n{\n\tchar\t*prompt_path;\n\tchar\t*joined;\n\tchar\t*tmp;\n\n\tif (!user_host)\n\t\treturn (NULL);\n\tprompt_path = ft_show_home(cwd);\n\tif (!prompt_path)\n\t\treturn (free(user_host), NULL);\n\tjoined = ft_strjoin(user_host, \" \" COLOR_PATH);\n\tfree(user_host);\n\tif (!joined)\n\t\treturn (free(prompt_path), NULL);\n\ttmp = ft_strjoin(joined, prompt_path);\n\tfree(joined);\n\tfree(prompt_path);\n\tif (!tmp)\n\t\treturn (NULL);\n\tjoined = ft_strjoin(tmp, COLOR_RESET PROMPT RESET);\n\tfree(tmp);\n\treturn (joined);\n}\n\nchar\t*ft_build_prompt(void)\n{\n\tchar\thostname[HOST_NAME_MAX + 1];\n\tchar\tcwd[PATH_MAX + 1];\n\tchar\t*user_host;\n\tchar\t*user;\n\n\tuser = getenv(\"USER\");\n\tif (!user)\n\t\tuser = \"user\";\n\tif (gethostname(hostname, sizeof(hostname)) != 0)\n\t\tft_strlcpy(hostname, \"minishell\", sizeof(hostname));\n\tif (!getcwd(cwd, sizeof(cwd)))\n\t\tft_strlcpy(cwd, \"?\", sizeof(cwd));\n\tuser_host = ft_prompt_userhost(user, hostname);\n\tif (!user_host)\n\t\treturn (NULL);\n\treturn (ft_prompt_path(user_host, cwd));\n}\n","size_bytes":3022},"SOURCE/main/signals.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   signals.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/21 10:46:17 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/10 18:38:10 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\n\n// void sigint_handler(int signo)\n// {\n//     (void)signo;\n    \n//     if (g_gb.last_sig == SIGINT_HEREDOC)\n//     {\n//         write(STDOUT_FILENO, \"\\n\", 1);\n//         g_gb.last_sig = SIGINT;\n//         return;\n//     }\n    \n//     // Set the signal flag\n//     g_gb.last_sig = SIGINT;\n    \n//     // Interrupt readline by setting done flag and clearing the line\n//     write(STDOUT_FILENO, \"\\n\", 1);\n//     rl_done = 1;\n//     rl_replace_line(\"\", 0);\n//     rl_point = rl_end = 0;\n    \n//     // Wake up readline\n//     rl_callback_handler_remove();\n// }\n\nvoid\tsigint_handler(int signo)\n{\n\t(void)signo;\n\tg_gb.last_sig = SIGINT;\n\n\t// For heredoc special case\n\t// if (g_gb.last_sig == SIGINT_HEREDOC) \n\t// {\n\t// \twrite(STDOUT_FILENO, \"\\n\", 1);\n\t// \treturn;\n\t// }\n\n\t// Normal input: cancel current line, redisplay prompt\n\twrite(STDOUT_FILENO, \"\\n\", 1);\n\trl_replace_line(\"\", 0);\n\trl_on_new_line();\n\trl_redisplay();\n     rl_done = 1;\n}\n\n\n\nvoid\tft_setup_signals(void)\n{\n\tstruct sigaction\tsa;\n\n\trl_catch_signals = 0;\n\trl_catch_sigwinch = 0;\n\tsa.sa_handler = sigint_handler;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_RESTART;\n\tsigaction(SIGINT, &sa, NULL);\n\tsignal(SIGQUIT, SIG_IGN);\n}\n\n\nint handle_nested_minishell(char **argv, char **envp)\n{\n    pid_t pid;\n    int status;\n\n    pid = fork();\n    if (pid < 0)\n    {\n        perror(\"fork\");\n        return (1);\n    }\n    if (pid == 0)\n    {\n        // --- Child process ---\n        // Reset signals to defaults\n        signal(SIGINT, SIG_DFL);\n        signal(SIGQUIT, SIG_DFL);\n\n        // Replace process with a new minishell\n        execve(argv[0], argv, envp);\n\n        // If execve fails:\n        perror(\"execve\");\n        exit(127);\n    }\n    else\n    {\n        waitpid(pid, &status, 0);\n\n        if (WIFEXITED(status))\n            g_gb.last_status_code = WEXITSTATUS(status);\n        else if (WIFSIGNALED(status))\n            g_gb.last_status_code = 128 + WTERMSIG(status);\n\n        return (g_gb.last_status_code);\n    }\n}\n","size_bytes":2905},"SOURCE/main/utils.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   utils.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/21 10:45:33 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/15 11:08:35 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nvoid\tft_clean_shell_setup(t_shell *shell)\n{\n\tif (!shell)\n\t\treturn ;\n\tft_free_env_list(&shell->env_list);\n\tft_free_commands(&shell->cmd_list);\n\tfree(shell);\n}\n\nvoid\tft_free_env_list(t_env_var **env_list)\n{\n\tt_env_var\t*tmp;\n\tt_env_var\t*current;\n\n\tif (!env_list || !*env_list)\n\t\treturn ;\n\tcurrent = *env_list;\n\twhile (current)\n\t{\n\t\ttmp = current->next_envar;\n\t\tif (current->envar_name)\n\t\t\tfree(current->envar_name);\n\t\tif (current->envar_value)\n\t\t\tfree(current->envar_value);\n\t\tfree(current);\n\t\tcurrent = tmp;\n\t}\n\t*env_list = NULL;\n}\n\nvoid\tfree_tokens(t_token *tokens)\n{\n\tt_token\t*tmp;\n\n\twhile (tokens)\n\t{\n\t\ttmp = tokens->next_token;\n\t\tif (tokens->token_value)\n\t\t\tfree(tokens->token_value);\n\t\tfree(tokens);\n\t\ttokens = tmp;\n\t}\n}\n\nvoid\tft_free_command_redirn_fds(t_comnd *cmd)\n{\n\tif (!cmd)\n\t\treturn ;\n\tif (cmd->infile_name)\n\t{\n\t\tfree(cmd->infile_name);\n\t\tcmd->infile_name = NULL;\n\t}\n\tif (cmd->outfile_name)\n\t{\n\t\tfree(cmd->outfile_name);\n\t\tcmd->outfile_name = NULL;\n\t}\n\tif (cmd->delimiter)\n\t{\n\t\tfree(cmd->delimiter);\n\t\tcmd->delimiter = NULL;\n\t}\n}\n\nvoid\tft_free_commands(t_comnd **cmd_list)\n{\n\tt_comnd\t*tmp;\n\tt_comnd\t*current;\n\tint\t\ti;\n\n\n\tif (!cmd_list || !*cmd_list)\n\t\treturn ;\n\n\tcurrent = *cmd_list;\n\twhile (current)\n\t{\n\t\ttmp = current->next;\n\n\t\t// free argv (string array)\n\t\tif (current->av_cmd)\n\t\t{\n\t\t\ti = 0;\n\t\t\twhile (current->av_cmd[i])\n\t\t\t\tfree(current->av_cmd[i++]);\n\t\t\tfree(current->av_cmd);\n\t\t}\n                if (current->av_cmd_lst)\n\t\t        free_tokens(current->av_cmd_lst);\n\n\t\t// free redirection names\n\t\tft_free_command_redirn_fds(current);\n\n\t\tfree(current);\n\t\tcurrent = tmp;\n\t}\n\t*cmd_list = NULL;\n}\n\n","size_bytes":2537},"SOURCE/main/utils2.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   utils2.c                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/21 10:47:52 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/11 13:40:17 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nvoid    ft_free_env_node(t_env_var *node)\n{\n        if (!node)\n                return ;\n        if (node->envar_name)\n                free(node->envar_name);\n        if (node->envar_value)\n                free(node->envar_value);\n        free(node);\n}\n\nvoid    ft_add_back(t_comnd **list, t_comnd *new_node)\n{\n        t_comnd *last;\n\n        if (!list || !new_node)\n                return ;\n        if (*list == NULL)\n        {\n                *list = new_node;\n                return ;\n        }\n        last = *list;\n        while (last->next != NULL)\n                last = last->next;\n        last->next = new_node;\n}\n\nt_token *ft_new_token(t_token_type type, char *value, int quote)\n{\n        t_token *token;\n\n        token = malloc(sizeof(t_token));\n        if (!token)\n                return (NULL);\n        token->quote = quote;\n        token->type = type;\n        token->token_value = value;\n        token->join_with_next = 0;\n        token->next_token = NULL;\n        return (token);\n}\n\nt_comnd *ft_create_command_node(void)\n{\n        t_comnd *command;\n\n        command = malloc(sizeof(t_comnd));\n        if (!command)\n                return (NULL);\n        command->av_cmd = NULL;\n        command->av_cmd_lst = NULL;\n        command->infile_name = NULL;\n        command->outfile_name = NULL;\n        command->delimiter = NULL;\n        command->infile = -1;\n        command->outfile = -1;\n        command->redirec_type = 0;\n        command->quote = 0;\n        command->next = NULL;\n        return (command);\n}\n\nt_env_var       *ft_create_env_list(const char *env_line)\n{\n        t_env_var       *env_node;\n        size_t          name_len;\n        char            *equal_sign_ptr;\n\n        env_node = malloc(sizeof(t_env_var));\n        if (!env_node)\n                return (NULL);\n        equal_sign_ptr = ft_strchr(env_line, '=');\n        if (!equal_sign_ptr)\n                return (ft_free_env_node(env_node), NULL);\n        name_len = equal_sign_ptr - env_line;\n        env_node->envar_name = ft_substr(env_line, 0, name_len);\n        if (!env_node->envar_name)\n                return (ft_free_env_node(env_node), NULL);\n        env_node->envar_value = ft_strdup(equal_sign_ptr + 1);\n        if (!env_node->envar_value)\n                return (ft_free_env_node(env_node), NULL);\n        env_node->next_envar = NULL;\n        return (env_node);\n}\n","size_bytes":3287},"SOURCE/main/utils3.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   utils3.c                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/27 12:06:18 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/15 11:06:02 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tcheck_unclosed_quotes(const char *line)\n{\n\tint\t\ti;\n\tchar\tquote;\n\n\ti = 0;\n\tquote = 0;\n\twhile (line[i])\n\t{\n\t\tif (!quote && (line[i] == '\\'' || line[i] == '\"'))\n\t\t\tquote = line[i];\n\t\telse if (quote && line[i] == quote)\n\t\t\tquote = 0;\n\t\ti++;\n\t}\n\treturn (quote != 0);\n}\n\nint\tcheck_incomplete_syntax(const char *line)\n{\n\tint\t\ti;\n\tchar\tquote;\n\n\ti = 0;\n\tquote = 0;\n\twhile (line[i])\n\t{\n\t\tif (!quote && (line[i] == '\\'' || line[i] == '\"'))\n\t\t\tquote = line[i];\n\t\telse if (quote && line[i] == quote)\n\t\t\tquote = 0;\n\t\ti++;\n\t}\n\tif (quote)\n\t\treturn (1);\n\twhile (i > 0 && (line[i - 1] == ' ' || line[i - 1] == '\\t'))\n\t\ti--;\n\tif (i > 0 && (line[i - 1] == '\\\\'\n\t\t\t|| line[i - 1] == '&'))\n\t\treturn (1);\n\treturn (0);\n}\n\nchar *read_line_interruptible(const char *prompt)\n{\n    char    *line;\n    char    buffer[4096];\n    int     i;\n    int     c;\n    fd_set  readfs;\n    struct timeval  timeout;\n    int     result;\n    \n    // Print prompt\n    write(STDOUT_FILENO, prompt, strlen(prompt));\n    fflush(stdout);\n    \n    // Reset signal flag\n    g_gb.last_sig = 0;\n    i = 0;\n    \n    // Read character by character using select() for proper signal handling\n    while (i < (int)(sizeof(buffer) - 1))\n    {\n        // Check for signal before each iteration\n        if (g_gb.last_sig == SIGINT)\n            return (NULL);\n        \n        // Set up select() to monitor stdin\n        FD_ZERO(&readfs);\n        FD_SET(STDIN_FILENO, &readfs);\n        \n        // Short timeout to allow signal checking\n        timeout.tv_sec = 0;\n        timeout.tv_usec = 100000; // 100ms timeout\n        \n        // Use select() to wait for input or timeout\n        result = select(STDIN_FILENO + 1, &readfs, NULL, NULL, &timeout);\n        \n        // Check for signal after select()\n        if (g_gb.last_sig == SIGINT)\n            return (NULL);\n        \n        if (result > 0 && FD_ISSET(STDIN_FILENO, &readfs))\n        {\n            // Input is available, read one character\n            c = getchar();\n            \n            // Check for signal after read\n            if (g_gb.last_sig == SIGINT)\n                return (NULL);\n            \n            if (c == EOF)\n            {\n                if (i == 0)\n                    return (NULL); // True EOF\n                break; // EOF after some input\n            }\n            \n            if (c == '\\n')\n                break;\n            \n            buffer[i++] = c;\n        }\n        else if (result == -1)\n        {\n            // select() error, possibly interrupted by signal\n            if (g_gb.last_sig == SIGINT)\n                return (NULL);\n            // Other error, continue\n        }\n        // result == 0 means timeout, continue the loop to check for signals\n    }\n    \n    buffer[i] = '\\0';\n    \n    // Return a copy of the buffer\n    line = ft_strdup(buffer);\n    return (line);\n}\n\nchar\t*read_secondary_input(char *line, const char *second_prompt)\n{\n\tchar\t*next;\n\tchar\t*tmp;\n\tchar\t*joined;\n\n\tnext = readline(second_prompt);\n\tif (g_gb.last_sig == SIGINT)\n\t{\n\t\tfree(line);\n\t\tfree(next);\n\t\treturn (NULL);\n\t}\n\tif (!next)\n\t\treturn (line);\n\ttmp = ft_strjoin(line, \"\\n\");\n\tfree(line);\n\tif (!tmp)\n\t{\n\t\tfree(next);\n\t\treturn (NULL);\n\t}\n\tjoined = ft_strjoin(tmp, next);\n\tfree(tmp);\n\tfree(next);\n\treturn (joined);\n}\nstatic char* read_line_from_stdin(void) {\n    char buffer[BUFFER_SIZE];\n    int idx = 0;\n    char c;\n    ssize_t n;\n\n    // Read one character at a time up to BUFFER_SIZE-1 (leave space for null)\n    while (idx < BUFFER_SIZE - 1) {\n        n = read(STDIN_FILENO, &c, 1);\n        if (n <= 0) break; // EOF or error\n        buffer[idx++] = c;\n        if (c == '\\n') break; // Stop at newline\n    }\n    if (idx == 0) return NULL; // Nothing was read\n\n    buffer[idx] = '\\0'; // Null terminate (guaranteed room)\n    return ft_strdup(buffer);\n}\n\nchar\t*read_input_with_quotes(const char *prompt, const char *second_prompt)\n{\n\tchar\t*line;\n\n\tg_gb.last_sig = 0;\n\t\n\t// Check if we're in interactive mode\n\tif (isatty(STDIN_FILENO) && prompt)\n\t{\n\t\t// Interactive mode: use readline with prompt\n\t\tline = readline(prompt);\n\t}\n\telse\n\t{\n\t\tline = read_line_from_stdin();\n\t}\n\n\t// Ctrl+D on first prompt → exit shell\n\tif (!line)\n\t\treturn (NULL);\n\n\t// Ctrl+C on first prompt → cancel line, return empty\n\tif (g_gb.last_sig == SIGINT)\n\t{\n\t\tfree(line);\n\t\treturn (NULL);\n\t}\n\n\t// Only handle quote continuation in interactive mode\n\tif (isatty(STDIN_FILENO) && prompt)\n\t{\n\t\twhile (check_unclosed_quotes(line))\n\t\t{\n\t\t\tchar *next = readline(second_prompt);\n\n\t\t\t// Ctrl+C inside continuation → cancel whole line\n\t\t\tif (g_gb.last_sig == SIGINT)\n\t\t\t{\n\t\t\t\tfree(line);\n\t\t\t\tfree(next);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\n\t\t\t// Ctrl+D inside continuation → stop and return partial input\n\t\t\tif (!next)\n\t\t\t\tbreak;\n\n\t\t\t// Concatenate\n\t\t\tchar *tmp = ft_strjoin(line, \"\\n\");\n\t\t\tfree(line);\n\t\t\tif (!tmp)\n\t\t\t{\n\t\t\t\tfree(next);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tchar *joined = ft_strjoin(tmp, next);\n\t\t\tfree(tmp);\n\t\t\tfree(next);\n\t\t\tif (!joined)\n\t\t\t\treturn (NULL);\n\t\t\tline = joined;\n\t\t}\n\t}\n\treturn (line);\n}\n\n","size_bytes":5928},"SOURCE/parser/parse_utils.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   parse_utils.c                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 14:05:48 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/11 14:03:21 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tis_redirection(t_token_type type)\n{\n\treturn (type == TOKEN_REDIRECT_IN || type == TOKEN_REDIRECT_OUT\n\t\t|| type == TOKEN_HEREDOC || type == TOKEN_APPEND);\n}\n\nvoid\tinit_command_args(t_cmd_args *args)\n{\n\targs->capacity = 8;\n\targs->argc = 0;\n\targs->argv = malloc(sizeof(char *) * args->capacity);\n\t args->arg_tokens = malloc(sizeof(t_token *) * args->capacity);\n    if (!args->argv || !args->arg_tokens)\n    {\n        free(args->argv);\n        free(args->arg_tokens);\n        args->argv = NULL;\n        args->arg_tokens = NULL;\n        args->capacity = 0;\n        args->argc = 0;\n    }\n}\n\nvoid\tcleanup_command_parsing(t_cmd_args *args, t_comnd *cmd)\n{\n\tint\ti;\n\n    if (args->argv)\n    {\n        i = 0;\n        while (i < args->argc)\n        {\n            free(args->argv[i]); // free duplicated strings\n            i++;\n        }\n        free(args->argv);\n    }\n    free(args->arg_tokens);\n\tft_free_commands(&cmd);\n}\n\nt_comnd\t*setup_command_parsing(void)\n{\n\tt_comnd\t*cmd;\n\n\tcmd = ft_create_command_node();\n\tif (!cmd)\n\t\treturn (NULL);\n\treturn (cmd);\n}\n","size_bytes":1978},"SOURCE/parser/parser.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   parser.c                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/29 19:08:47 by robello           #+#    #+#             */\n/*   Updated: 2025/09/11 14:54:20 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\n// Add to SOURCE/parser/parser.c\nint\tft_check_syntax_errors(t_token *tokens)\n{\n\tt_token\t*current;\n\tt_token\t*next;\n\n\tif (!tokens)\n\t\treturn (0);\n\t\n\tcurrent = tokens;\n\t\n\t// Check for leading pipe\n\tif (current->type == TOKEN_PIPE)\n\t\treturn (1);\n\t\n\twhile (current)\n\t{\n\t\tnext = current->next_token;\n\t\t\n\t\t// Check for consecutive pipes\n\t\tif (current->type == TOKEN_PIPE && next && next->type == TOKEN_PIPE)\n\t\t\treturn (1);\n\t\t\n\t\t// Check for trailing pipe\n\t\tif (current->type == TOKEN_PIPE && !next)\n\t\t\treturn (1);\n\t\t\n\t\t// Check for redirect without filename\n\t\tif ((current->type == TOKEN_REDIRECT_IN || \n\t\t\t current->type == TOKEN_REDIRECT_OUT ||\n\t\t\t current->type == TOKEN_HEREDOC ||\n\t\t\t current->type == TOKEN_APPEND) && \n\t\t\t(!next || next->type != TOKEN_WORD))\n\t\t\treturn (1);\n\t\t\n\t\t// Check for consecutive redirects\n\t\tif ((current->type == TOKEN_REDIRECT_IN || \n\t\t\t current->type == TOKEN_REDIRECT_OUT ||\n\t\t\t current->type == TOKEN_HEREDOC ||\n\t\t\t current->type == TOKEN_APPEND) && \n\t\t\tnext && (next->type == TOKEN_REDIRECT_IN || \n\t\t\t\t\tnext->type == TOKEN_REDIRECT_OUT ||\n\t\t\t\t\tnext->type == TOKEN_HEREDOC ||\n\t\t\t\t\tnext->type == TOKEN_APPEND))\n\t\t\treturn (1);\n\t\t\n\t\tcurrent = next;\n\t}\n\treturn (0);\n}\n\nvoid\tft_handle_syntax_error(t_shell *shell, const char *error_msg)\n{\n\tft_putstr_fd(\"minishell: syntax error near unexpected token `\", 2);\n\tft_putstr_fd(error_msg, 2);\n\tft_putstr_fd(\"'\\n\", 2);\n\tshell->last_status = 2;\n}\nstatic t_token *build_token_list_from_args(t_cmd_args *args)\n{\n    t_token *head = NULL;\n    t_token *prev = NULL;\n    int     i;\n\n    i = 0;\n    while (i < args->argc)\n    {\n        if (!head)\n            head = args->arg_tokens[i];\n        else\n            prev->next_token = args->arg_tokens[i];\n        prev = args->arg_tokens[i];\n        i++;\n    }\n    if (prev)\n        prev->next_token = NULL;\n    return head;\n}\nt_comnd\t*ft_parse_command(t_token **tok_ptr)\n{\n\tt_comnd\t\t*cmd;\n\tt_cmd_args\targs;\n\tint\t\t\tres;\n\n\tcmd = setup_command_parsing();\n\tif (!cmd)\n\t\treturn (NULL);\n\tinit_command_args(&args);\n\tif (!args.argv || !args.arg_tokens)\n\t\treturn (ft_free_commands(&cmd), NULL);\n\twhile (*tok_ptr && (*tok_ptr)->type != TOKEN_PIPE)\n\t{\n\t\tres = process_token(tok_ptr, cmd, &args);\n\t\t\t\n\t\tif (res <= 0)\n\t\t{\n\t\t\tif (res < 0)\n\t\t\t\tcleanup_command_parsing(&args, cmd);\n\t\t\telse\n\t\t\t{\n                // partial cleanup if add_argument failed before any tokens were duplicated\n                if (args.argv)\n                {\n                    int i = 0;\n                    while (i < args.argc)\n                        free(args.argv[i++]);\n                    free(args.argv);\n                }\n                free(args.arg_tokens);\n                ft_free_commands(&cmd);\n            }\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\targs.argv[args.argc] = NULL;\n\tcmd->av_cmd = args.argv;\n\tcmd->av_cmd_lst = build_token_list_from_args(&args);\n\tfree(args.arg_tokens);\n\treturn (cmd);\n}\n\nt_comnd\t*ft_build_cmdline(t_comnd **first, t_comnd **last, t_token **current)\n{\n\tt_comnd\t*cmd;\n\n\tcmd = ft_parse_command(current);\n\tif (!cmd)\n\t\treturn (NULL);\n\tif (!*first)\n\t{\n\t\t*first = cmd;\n\t\t*last = cmd;\n\t}\n\telse\n\t{\n\t\t(*last)->next = cmd;\n\t\t*last = cmd;\n\t}\n\treturn (*last);\n}\n\nt_token\t*handle_pipe_token(t_token *current)\n{\n\tif (current && current->type == TOKEN_PIPE)\n\t\treturn (current->next_token);\n\telse if (current)\n\t{\n\t\tft_putstr_fd(\"minishell: syntax error near unexpected token\\n\", 2);\n\t\tg_gb.last_status_code = 2;\n\t\treturn (NULL);\n\t}\n\treturn (current);\n}\n\nint\tft_validate_redirect_syntax(t_token *tokens)\n{\n\tt_token\t*current;\n\tt_token\t*next;\n\n\tcurrent = tokens;\n\twhile (current)\n\t{\n\t\tnext = current->next_token;\n\t\t\n\t\t// Check for redirect without filename\n\t\tif ((current->type == TOKEN_REDIRECT_IN || \n\t\t\t current->type == TOKEN_REDIRECT_OUT ||\n\t\t\t current->type == TOKEN_HEREDOC ||\n\t\t\t current->type == TOKEN_APPEND) && \n\t\t\t(!next || next->type != TOKEN_WORD))\n\t\t{\n\t\t\tif (current->type == TOKEN_REDIRECT_OUT)\n\t\t\t{\n\t\t\t\tif (!next)\n\t\t\t\t\tft_put_syntax_error(\"newline\");\n\t\t\t\telse\n\t\t\t\t\tft_put_syntax_error(\">\");\n\t\t\t}\n\t\t\telse if (current->type == TOKEN_REDIRECT_IN)\n\t\t\t{\n\t\t\t\tif (!next)\n\t\t\t\t\tft_put_syntax_error(\"newline\");\n\t\t\t\telse\n\t\t\t\t\tft_put_syntax_error(\"<\");\n\t\t\t}\n\t\t\telse if (current->type == TOKEN_HEREDOC)\n\t\t\t{\n\t\t\t\tif (!next)\n\t\t\t\t\tft_put_syntax_error(\"newline\");\n\t\t\t\telse\n\t\t\t\t\tft_put_syntax_error(\"<<\");\n\t\t\t}\n\t\t\telse if (current->type == TOKEN_APPEND)\n\t\t\t{\n\t\t\t\tif (!next)\n\t\t\t\t\tft_put_syntax_error(\"newline\");\n\t\t\t\telse if (next->type == TOKEN_REDIRECT_OUT)\n\t\t\t\t\tft_put_syntax_error(\">\");\n\t\t\t\telse\n\t\t\t\t\tft_put_syntax_error(\">>\");\n\t\t\t}\n\t\t\treturn (1);\n\t\t}\n\t\t\n\t\t// Check for consecutive redirects\n\t\tif ((current->type == TOKEN_REDIRECT_IN || \n\t\t\t current->type == TOKEN_REDIRECT_OUT ||\n\t\t\t current->type == TOKEN_HEREDOC ||\n\t\t\t current->type == TOKEN_APPEND) && \n\t\t\tnext && (next->type == TOKEN_REDIRECT_IN || \n\t\t\t\t\tnext->type == TOKEN_REDIRECT_OUT ||\n\t\t\t\t\tnext->type == TOKEN_HEREDOC ||\n\t\t\t\t\tnext->type == TOKEN_APPEND))\n\t\t{\n\t\t\tif (next->type == '\\n')\n\t\t\t\tft_put_syntax_error(\"newline\");\n\t\t\tif (next->type == TOKEN_REDIRECT_OUT)\n\t\t\t\tft_put_syntax_error(\">\");\n\t\t\telse if (next->type == TOKEN_REDIRECT_IN)\n\t\t\t\tft_put_syntax_error(\"<\");\n\t\t\telse if (next->type == TOKEN_HEREDOC)\n\t\t\t\tft_put_syntax_error(\"<<\");\n\t\t\telse if (next->type == TOKEN_APPEND)\n\t\t\t\tft_put_syntax_error(\">>\");\n\t\t\treturn (1);\n\t\t}\n\t\t\n\t\tcurrent = next;\n\t}\n\treturn (0);\n}\n\nint\tft_validate_pipe_syntax(t_token *tokens)\n{\n\tt_token\t*current;\n\tt_token\t*next;\n\n\tif (!tokens)\n\t\treturn (0);\n\t\n\tcurrent = tokens;\n\t\n\t// Check for leading pipe\n\tif (current->type == TOKEN_PIPE)\n\t{\n\t\tft_put_syntax_error(\"|\");\n\t\treturn (1);\n\t}\n\t\n\twhile (current)\n\t{\n\t\tnext = current->next_token;\n\t\t\n\t\t// Check for consecutive pipes\n\t\tif (current->type == TOKEN_PIPE && next && next->type == TOKEN_PIPE)\n\t\t{\n\t\t\tft_put_syntax_error(\"|\");\n\t\t\treturn (1);\n\t\t}\n\t\t\n\t\t// Check for trailing pipe\n\t\tif (current->type == TOKEN_PIPE && !next)\n\t\t{\n\t\t\tft_put_syntax_error(\"|\");\n\t\t\treturn (1);\n\t\t}\n\t\t\n\t\tcurrent = next;\n\t}\n\treturn (0);\n}\n\nt_comnd\t*ft_parser_main(t_token *tokens)\n{\n\tt_comnd\t*first;\n\tt_comnd\t*last;\n\tt_token\t*current;\n\n\tfirst = NULL;\n\tlast = NULL;\n\tcurrent = tokens;\n\n\tif (ft_validate_pipe_syntax(tokens) || ft_validate_redirect_syntax(tokens))\n\t{\n\t\t// Exit code 2 is already set by the validation functions\n\t\treturn (NULL);\n\t}\n\twhile (current)\n\t{\n\t\tlast = ft_build_cmdline(&first, &last, &current);\n\t\tif (!last)\n\t\t{\n\t\t\tft_free_commands(&first);\n\t\t\tg_gb.last_status_code = 2;\n\t\t\treturn (NULL);\n\t\t}\n\t\tcurrent = handle_pipe_token(current);\n\t}\n\treturn (first);\n}\n","size_bytes":7395},"SOURCE/parser/parser_helper.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   parser_helper.c                                    :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 14:07:04 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/11 14:10:15 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nstatic int\thandle_redirection_error(t_token *filename_token)\n{\n\tchar *str;\n\n\tif (!filename_token)\n\t\tstr = \"newline\";\n\telse\n\t\tstr = filename_token->token_value;\n\tft_putstr_fd(\"minishell: syntax error near unexpected token `\", 2);\n\tft_putstr_fd(str, 2);\n\tft_putstr_fd(\"'\\n\", 2);\n\tg_gb.last_status_code = 2;\n\treturn (1);\n}\n\n\nint\tprocess_redirection(t_token *token, t_comnd *cmd)\n{\n\tchar\t\t\t**target;\n\tt_token\t\t\t*filename_token;\n\tt_token_type\tredir_type;\n\tint\t\t\t\tfd;\n\n\tfilename_token = token->next_token;\n\tif (!filename_token)\n    \treturn (handle_redirection_error(NULL)); //2\n\ttarget = NULL;\n\tredir_type = token->type;\n\tif (redir_type == TOKEN_HEREDOC)\n\t\ttarget = &cmd->delimiter;\n\telse if (redir_type == TOKEN_REDIRECT_OUT || redir_type == TOKEN_APPEND)\n\t{\n\t\ttarget = &cmd->outfile_name;\n\t\t// If there's already an outfile name, create that file (like bash does)\n\t\tif (*target)\n\t\t{\n\t\t\tif (redir_type == TOKEN_REDIRECT_OUT)\n\t\t\t\tfd = open(*target, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\t\t\telse // TOKEN_APPEND\n\t\t\t\tfd = open(*target, O_WRONLY | O_CREAT | O_APPEND, 0644);\n\t\t\tif (fd >= 0)\n\t\t\t\tclose(fd);\n\t\t\t// Don't return error here - bash continues even if intermediate files fail\n\t\t}\n\t}\n\telse if (redir_type == TOKEN_REDIRECT_IN)\n\t\ttarget = &cmd->infile_name;\n\tif (*target)\n\t\tfree(*target);\n\t*target = ft_strdup(filename_token->token_value);\n\tif (!*target)\n\t\treturn (-1);\n\tcmd->redirec_type = redir_type;\n\treturn (1);\n}\n\nint\tparse_redirection(t_token **tok_ptr, t_comnd *cmd)\n{\n\tint ret;\n\tt_token\t*token;\n\n\ttoken = *tok_ptr;\n\tif (!token || !is_redirection(token->type))\n\t\treturn (0);\n\tret = process_redirection(token, cmd);\n\tif (ret > 0)\n\t{\n\t\tif (token->next_token)\n\t\t\t*tok_ptr = token->next_token->next_token;\n\t\telse\n\t\t\t*tok_ptr = NULL;\n\t}\n\treturn (ret);\n}\n\nt_token *dup_token(const t_token *src)\n{\n    t_token *new;\n\n    if (!src)\n        return NULL;\n    new = malloc(sizeof(t_token));\n    if (!new)\n        return NULL;\n    new->type = src->type;\n    new->quote = src->quote;\n    new->token_value = ft_strdup(src->token_value);\n    if (!new->token_value)\n    {\n        free(new);\n        return NULL;\n    }\n    new->next_token = NULL;\n    return new;\n}\n\nint\tadd_argument(t_cmd_args *args, t_token *token)\n{\n\tchar\t**tmp;\n\tt_token\t**tmp_tokens;\n\tt_token *newtok;\n\t \n\tif (args->argc + 1 >= args->capacity)\n\t{\n\t\ttmp = realloc(args->argv, sizeof(char *) * args->capacity * 2);\n\t\tif (!tmp)\n\t\t\treturn (0);\n\t\targs->argv = tmp;\n\n\t\ttmp_tokens = realloc(args->arg_tokens, sizeof(t_token *) * args->capacity * 2);\n\t\tif (!tmp_tokens)\n\t\t\treturn 0;\n\t\targs->arg_tokens = tmp_tokens;\n\t\t\n\t\targs->capacity *= 2;\n\t}\n\targs->argv[args->argc] = ft_strdup(token->token_value);\n\tif (!args->argv[args->argc])\n\t\treturn (0);\n\tnewtok = dup_token(token);\n    if (!newtok)\n    {\n        free(args->argv[args->argc]);\n        return (0);\n    }\n\n    args->arg_tokens[args->argc] = newtok;\n\targs->argc++;\n\treturn (1);\n}\n\nint\tprocess_token(t_token **token_ptr, t_comnd *cmd, t_cmd_args *args)\n{\n\tt_token\t*token;\n\tint\t\tres;\n\n\ttoken = *token_ptr;\n\tif (token->quote == 1)\n\t\tcmd->quote = 1;\n\telse if (token->quote == 2)\n\t\tcmd->quote = 2;\n\tif (token->type == TOKEN_WORD)\n\t{\n\t\t// Allow parentheses for array assignments (VAR=(...)) and quoted strings\n\t\tif ((ft_strchr(token->token_value, '(') || ft_strchr(token->token_value, ')'))\n\t\t\t&& !ft_is_array_assignment(token->token_value) && token->quote == NA)\n\t\t{\n\t\t\tft_putstr_fd(\"minishell: syntax error near unexpected token `\", 2);\n\t\t\tft_putstr_fd(token->token_value, 2);\n\t\t\tft_putstr_fd(\"'\\n\", 2);\n\t\t\tg_gb.last_status_code = 2;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (!add_argument(args, token))\n\t\t\treturn (0);\n\t\t*token_ptr = token->next_token;\n\t}\n\telse if (is_redirection(token->type))\n\t{\n\t\tres = parse_redirection(token_ptr, cmd);\n\t\tif (res <= 0)\n\t\t\treturn (res);\n\t}\n\telse\n\t{\n\t\tft_putstr_fd(\"minishell: syntax error near unexpected token\\n\", 2);\n\t\tg_gb.last_status_code = 2;\n\t\treturn (-1);\n\t}\n\treturn (1);\n}\n","size_bytes":4830},"SOURCE/pipe/pipe.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   pipe.c                                             :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/07 11:53:50 by robello           #+#    #+#             */\n/*   Updated: 2025/09/15 11:58:03 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nvoid\topen_infile_silent(t_comnd *cmd)\n{\n\tif (cmd->infile != -1)\n\t\tclose(cmd->infile);\n\tcmd->infile = open(cmd->infile_name, O_RDONLY);\n\t// Don't print any error messages, just set infile = -1 if it fails\n\tif (cmd->infile < 0)\n\t\tcmd->infile = -1;\n}\n\nstatic void\texecute_pipeline_loop(t_comnd *cmds, t_shell *shell, pid_t *pids,\n\t\tchar **envp)\n{\n\tt_pipe\tctx;\n\tint status;\n\n\t(void)status;\n\tctx.cmd = cmds;\n\tctx.shell = shell;\n\tctx.pids = pids;\n\tctx.prev = -1;\n\tctx.i = 0;\n\tctx.envp = envp;\n\n\tft_open_main(ctx.cmd, 0);\n\twhile (ctx.cmd)\n\t{\n\t\tsetup_pipe(ctx.pfd, ctx.cmd);\n\t\tlaunch_child(&ctx);\n\t\tclose_parent_fds(&ctx.prev, ctx.pfd);\n\t\tctx.cmd = ctx.cmd->next;\n\t\tctx.i++;\n\t}\n\tft_wait_all(pids, ctx.i, shell);\n}\n\n\n\n//#ifdef DEBUG\nvoid    print_command(const t_comnd *cmd)\n{\n    int i;\n\n    if (!cmd)\n    {\n        printf(\"Command: (null)\\n\");\n        return;\n    }\n\n    printf(\"=== Command ===\\n\");\n\n    // Print argv\n    if (cmd->av_cmd)\n    {\n        i = 0;\n        while (cmd->av_cmd[i])\n        {\n            printf(\"  av_cmd[%d] = [%s]\\n\", i, cmd->av_cmd[i]);\n            i++;\n        }\n    }\n    else\n        printf(\"  av_cmd = (null)\\n\");\n\n    // Print file names\n    printf(\"  infile_name   = [%s]\\n\", cmd->infile_name ? cmd->infile_name : \"(null)\");\n    printf(\"  outfile_name  = [%s]\\n\", cmd->outfile_name ? cmd->outfile_name : \"(null)\");\n    printf(\"  delimiter     = [%s]\\n\", cmd->delimiter ? cmd->delimiter : \"(null)\");\n\n    // Print file descriptors and flags\n    printf(\"  infile        = %d\\n\", cmd->infile);\n    printf(\"  outfile       = %d\\n\", cmd->outfile);\n    printf(\"  redirec_type  = %d\\n\", cmd->redirec_type);\n    printf(\"  quote         = %d\\n\", cmd->quote);\n\n    // Pointer to next command\n    printf(\"  next          = %p\\n\", (void*)cmd->next);\n    printf(\"================\\n\");\n}\nvoid print_command_list(const t_comnd *cmd)\n{\n    int i = 1;\n    while (cmd)\n    {\n        printf(\"\\n--- Command #%d ---\\n\", i);\n        print_command(cmd);              // show argv / redirs\n        print_tokens(cmd->av_cmd_lst);   // show token list\n\n        cmd = cmd->next;  // ✅ advance to next command\n        i++;\n    }\n}\n//#endif\n\nvoid\tft_pipe_up_bonus(t_comnd *cmds, t_shell *shell)\n{\n\tpid_t\t*pids;\n\tchar\t**envp;\n\tint\t\tcount;\n\n    (void)count;\n\tcount = setup_allocations(cmds, shell, &pids, &envp);\n\tif (handle_parent_builtin(cmds, shell, envp, pids))\n\t\treturn ;\n\texecute_pipeline_loop(cmds, shell, pids, envp);\n\tcleanup_all_fds(cmds);\n\tfree_env_array(envp);\n\tfree(pids);\n}\n","size_bytes":3414},"SOURCE/pipe/pipe_utils.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   pipe_utils.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 11:16:47 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/02 11:16:46 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tsetup_allocations(t_comnd *cmds, t_shell *shell, pid_t **pids, char ***envp)\n{\n\tint\tcount;\n\n\tcount = count_cmds(cmds);\n\t*pids = malloc(sizeof(pid_t) * count);\n\t*envp = ft_env_list_to_array(shell->env_list);\n\tif (!*pids || !*envp)\n\t\tft_error_exit(\"alloc\");\n\treturn (count);\n}\n\nint\thandle_parent_builtin(t_comnd *cmds, t_shell *shell, char **envp,\n\t\tpid_t *pids)\n{\n\tif (is_parent_builtin(cmds))\n\t{\n\t\tshell->last_status = ft_dispatch_builtin_with_arrays(cmds->av_cmd, &shell->env_list,\n\t\t\t\tshell);\n\t\tfree_env_array(envp);\n\t\tcleanup_all_fds(cmds);\n\t\tfree(pids);\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nvoid\tsetup_pipe(int pfd[2], t_comnd *current)\n{\n\tif (current->next)\n\t{\n\t\tif (pipe(pfd) < 0)\n\t\t\tft_error_exit(\"pipe\");\n\t}\n\telse\n\t{\n\t\tpfd[0] = -1;\n\t\tpfd[1] = -1;\n\t}\n}\n\nvoid\tlaunch_child(t_pipe *ctx)\n{\n\tctx->pids[ctx->i] = fork();\n\tif (ctx->pids[ctx->i] < 0)\n\t\tft_error_exit(\"fork\");\n\tif (ctx->pids[ctx->i] == 0)\n\t\trun_child(ctx);\n}\n\nvoid\tclose_parent_fds(int *prev, int pfd[2])\n{\n\tif (*prev >= 0)\n\t\tclose(*prev);\n\tif (pfd[1] >= 0)\n\t\tclose(pfd[1]);\n\t*prev = pfd[0];\n}\n","size_bytes":1987},".ccls-cache/@home@runner@workspace/SOURCE@main@main.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.c                                             :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/29 19:07:32 by robello           #+#    #+#             */\n/*   Updated: 2025/09/15 12:15:27 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nt_gb g_gb = {0, 0};\n\n// Add to SOURCE/main/main.c\nint\tft_handle_parsing_error(t_token *tokens, char *input_line, t_shell *shell)\n{\n\tif (tokens)\n\t\tfree_tokens(tokens);\n\tif (input_line)\n\t\tfree(input_line);\n\tshell->last_status = 2; // Syntax error\n\treturn (0);\n}\n\n// Add to SOURCE/main/main.c\nvoid\tft_update_signal_exit_codes(t_shell *shell)\n{\n\tif (g_gb.last_sig == SIGINT)\n\t{\n\t\tshell->last_status = 130;\n\t\tg_gb.last_status_code = 130;\n\t}\n\telse if (g_gb.last_sig == SIGQUIT)\n\t{\n\t\tshell->last_status = 131;\n\t\tg_gb.last_status_code = 131;\n\t}\n}\n\nt_shell\t*ft_init_shell(void)\n{\n\tt_shell\t*shell;\n\n\tshell = malloc(sizeof(t_shell));\n\tif (!shell)\n\t\treturn (NULL);\n\tshell->env_list = NULL;\n\tshell->cmd_list = NULL;\n\tshell->array_list = NULL;\n\tshell->last_status = 0;\n\treturn (shell);\n}\n\nt_shell\t*ft_shell_setup(char **env_vars)\n{\n\tt_shell\t*shell;\n\n\tshell = ft_init_shell();\n\tif (!shell)\n\t\treturn (NULL);\n\tshell->envp = env_vars;\n\tshell->env_list = ft_build_env_list(env_vars);\n\treturn (shell);\n}\n\nint\tft_manage_inputline(char *input_line, t_shell *shell)\n{\n\tt_token\t*tokens;\n\n\tif (!input_line)\n\t\treturn (1);\n\tif (*input_line)\n\t{\n\t\tadd_history(input_line);\n\t\tshell->line_cnt++;\n\t}\n\tft_trim_newline(input_line);\n\t// Reset global status before parsing\n\tg_gb.last_status_code = 0;\n\ttokens = ft_lexer_main(input_line);\n\tif (!tokens)\n\t\treturn (free(input_line), 0);\n\t//quotes_tokens(tokens);\n\t//print_tokens(tokens);\n\tshell->cmd_list = ft_parser_main(tokens);\n\t//print_command_list(shell->cmd_list); // Debugging line to print commands\n\tfree_tokens(tokens);\n\tfree(input_line);\n\tif (!shell->cmd_list)\n\t{\n\t\t// Check if it's a redirection error (exit code 1) or syntax error (exit code 2)\n\t\tif (g_gb.last_status_code == 1)\n\t\t\tshell->last_status = 1; // Redirection error\n\t\telse\n\t\t\tshell->last_status = 2; // Syntax error\n\t\treturn (0);\n\t}\n\tft_expand_cmds(shell->cmd_list, shell);\n\tft_start_execution(shell->cmd_list, shell);\n\tft_free_commands(&shell->cmd_list);\n\treturn (0);\n}\n\nvoid\tmaster_shell_loop(t_shell *shell)\n{\n\tchar\t*prompt_line;\n\tchar\t*input_line;\n\tint loop;\n\tint is_interactive;\n\t\n\tloop = 0;\n\tis_interactive = isatty(STDIN_FILENO);\n\twhile (!loop)\n\t{\n\t\t// Reset signal before each prompt\n\t\tg_gb.last_sig = 0;\n\t\t\n\t\tif (is_interactive)\n\t\t{\n\t\t\tprompt_line = ft_build_prompt();\n\t\t\tif (!prompt_line)\n\t\t\t\tcontinue ;\n\t\t}\n\t\telse\n\t\t\tprompt_line = NULL;\n\t\t\n\t\tinput_line = read_input_with_quotes(prompt_line, \"> \");\n\t\tif (prompt_line)\n\t\t\tfree(prompt_line);\n\t\t\n\t\t// Handle SIGINT or NULL input\n\t\t\n\t\tif (g_gb.last_sig == SIGINT)\n\t\t{\n\t\t    free(input_line);\n\t\t    continue;\n\t\t}\n\t\t\n\t\t// EOF → exit shell\n\t\tif (!input_line)\n\t\t{\n\t\t\t// Only print EOF in interactive mode\n\t\t\tif (is_interactive)\n\t\t\t\tft_putstr_fd(RED \"exit\\n\" RESET, 1);\n\t\t    break;\n\t\t}\n\t\t// Process the complete input line\n\t\tloop = ft_manage_inputline(input_line, shell);\n\t\tg_gb.last_status_code = shell->last_status;\n\t\tft_update_signal_exit_codes(shell);\n\t}\n}\n\nint\tmain(int ac, char **av, char **env_vars)\n{\n\tt_shell\t*shell;\n\n\t(void)ac;\n\t(void)av;\n\tft_setup_signals();\n\t\n\tshell = ft_shell_setup(env_vars);\n\tif (!shell)\n\t\texit(EXIT_FAILURE);\n\tmaster_shell_loop(shell);\n\trl_clear_history();\n\tft_clean_shell_setup(shell);\n\treturn (g_gb.last_status_code);\n}\n","size_bytes":4120},".ccls-cache/@home@runner@workspace/SOURCE@main@utils2.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   utils2.c                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/21 10:47:52 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/11 13:40:17 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nvoid    ft_free_env_node(t_env_var *node)\n{\n        if (!node)\n                return ;\n        if (node->envar_name)\n                free(node->envar_name);\n        if (node->envar_value)\n                free(node->envar_value);\n        free(node);\n}\n\nvoid    ft_add_back(t_comnd **list, t_comnd *new_node)\n{\n        t_comnd *last;\n\n        if (!list || !new_node)\n                return ;\n        if (*list == NULL)\n        {\n                *list = new_node;\n                return ;\n        }\n        last = *list;\n        while (last->next != NULL)\n                last = last->next;\n        last->next = new_node;\n}\n\nt_token *ft_new_token(t_token_type type, char *value, int quote)\n{\n        t_token *token;\n\n        token = malloc(sizeof(t_token));\n        if (!token)\n                return (NULL);\n        token->quote = quote;\n        token->type = type;\n        token->token_value = value;\n        token->join_with_next = 0;\n        token->next_token = NULL;\n        return (token);\n}\n\nt_comnd *ft_create_command_node(void)\n{\n        t_comnd *command;\n\n        command = malloc(sizeof(t_comnd));\n        if (!command)\n                return (NULL);\n        command->av_cmd = NULL;\n        command->av_cmd_lst = NULL;\n        command->infile_name = NULL;\n        command->outfile_name = NULL;\n        command->delimiter = NULL;\n        command->infile = -1;\n        command->outfile = -1;\n        command->redirec_type = 0;\n        command->quote = 0;\n        command->next = NULL;\n        return (command);\n}\n\nt_env_var       *ft_create_env_list(const char *env_line)\n{\n        t_env_var       *env_node;\n        size_t          name_len;\n        char            *equal_sign_ptr;\n\n        env_node = malloc(sizeof(t_env_var));\n        if (!env_node)\n                return (NULL);\n        equal_sign_ptr = ft_strchr(env_line, '=');\n        if (!equal_sign_ptr)\n                return (ft_free_env_node(env_node), NULL);\n        name_len = equal_sign_ptr - env_line;\n        env_node->envar_name = ft_substr(env_line, 0, name_len);\n        if (!env_node->envar_name)\n                return (ft_free_env_node(env_node), NULL);\n        env_node->envar_value = ft_strdup(equal_sign_ptr + 1);\n        if (!env_node->envar_value)\n                return (ft_free_env_node(env_node), NULL);\n        env_node->next_envar = NULL;\n        return (env_node);\n}\n","size_bytes":3287},"replit.md":{"content":"# Minishell Project\n\n## Overview\nThis is a C project implementing a minimal shell (minishell) that mimics bash functionality. It's originally a GitHub import that needs to be set up to run in the Replit environment.\n\n## Project Architecture\n- **Language**: C with make build system\n- **Key Components**:\n  - Shell parsing and lexing\n  - Command execution and piping\n  - Built-in commands (cd, echo, env, exit, export, pwd, unset)\n  - Environment variable expansion\n  - Signal handling\n  - Readline integration for command line input\n\n## Current Setup Status\n- ✅ C compiler (clang-14) installed\n- ✅ Readline library installed with proper headers and linking\n- ✅ Fixed header include path issues\n- ✅ Fixed C keyword conflicts (renamed 'new' parameter to 'new_node')  \n- ✅ Fixed Makefile tab/space formatting issues\n- ✅ Project builds successfully\n- ✅ Console workflow configured and running\n\n## Recent Changes (Sept 15, 2025)\n- Fixed include path for `get_next_line_bonus.h` in `SOURCE/include/minishell.h`\n- Renamed function parameter `new` to `new_node` to avoid C keyword conflict in both header and implementation\n- Added readline system dependency with proper header and library linking\n- Updated Makefile CFLAGS to include proper include directories: `$(NIX_CFLAGS_COMPILE)`\n- Updated Makefile linking to include Nix library paths: `$(NIX_LDFLAGS)`\n- Fixed Makefile tab/space indentation issues using AWK script\n- Configured \"Minishell\" console workflow for interactive shell usage\n\n## Usage Instructions\n- **Run minishell**: Use the \"Minishell\" workflow in the console panel\n- **Rebuild project**: Run `make clean && make` in the terminal\n- **Available commands**: Built-in commands (cd, echo, env, exit, export, pwd, unset) and external commands via PATH\n- **Features**: Command history, pipes, redirections, variable expansion, signal handling\n\n## Dependencies\n- System: readline library\n- Build: make, clang compiler\n- Libraries: libft (custom C library), get_next_line\n\n## File Structure\n```\nSOURCE/\n├── include/\n│   ├── minishell.h     # Main header file\n│   └── colors.h        # Color definitions\n├── main/               # Main program logic\n├── lexer/              # Tokenization and parsing\n├── parser/             # Command parsing\n├── execute/            # Command execution\n├── built/              # Built-in commands\n├── expansion/          # Variable expansion\n├── pipe/               # Pipe handling\n├── gnl/                # Get next line utility\n└── libft/              # Custom C library\n```\n\n## User Preferences\n- Project imported from GitHub, should maintain existing structure and conventions\n- Needs to run as terminal-based application (TUI/console app)","size_bytes":2771},".ccls-cache/@home@runner@workspace/SOURCE@expansion@expansion.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   expansion.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/27 12:21:12 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/09/11 14:55:46 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\n// static char\t*ft_expand_braced_var(const char *input, size_t *idx_ptr,\n// \t\tt_shell *shell)\n// {\n// \tsize_t\tstart;\n// \tchar\t*var_name;\n// \tchar\t*string;\n\n// \t(*idx_ptr)++;\n// \tstart = *idx_ptr;\n// \twhile (input[*idx_ptr] && input[*idx_ptr] != '}')\n// \t\t(*idx_ptr)++;\n// \tif (input[*idx_ptr] != '}')\n// \t\treturn (ft_strdup(\"${\"));\n// \tvar_name = ft_substr(input, start, *idx_ptr - start);\n// \tif (!var_name)\n// \t\treturn (NULL);\n// \tstring = ft_dup_env_value(var_name, shell);\n// \tif (!string)\n// \t\tstring = ft_strdup(\"\");\n// \tfree(var_name);\n// \t(*idx_ptr)++;\n// \treturn (string);\n// }\n\n// static char\t*expand_last_status(size_t *idx_ptr, t_shell *shell)\n// {\n// \t(*idx_ptr)++;\n// \treturn (ft_get_lastcmd_string(shell->last_status));\n// }\n\n// char\t*ft_process_dollar(const char *input, size_t *idx_ptr, t_shell *shell)\n// {\n// \tsize_t\tstart;\n// \tchar\t*string;\n// \tchar\t*var_name;\n\n// \tif (input[*idx_ptr] == '?')\n// \t\treturn (expand_last_status(idx_ptr, shell));\n//     if (input[*idx_ptr]  == '$') // special case: PID\n//     {\n//         (*idx_ptr)++;\n//         return ft_itoa(getpid());\n//     }\n// \tif (input[*idx_ptr] == '{')\n// \t\treturn (ft_expand_braced_var(input, idx_ptr, shell));\n// \tif (is_valid_var_char(input[*idx_ptr], 1))\n// \t{\n// \t\tstart = *idx_ptr;\n// \t\twhile (input[*idx_ptr] && is_valid_var_char(input[*idx_ptr], 0))\n// \t\t\t(*idx_ptr)++;\n// \t\tvar_name = ft_substr(input, start, *idx_ptr - start);\n// \t\tif (!var_name)\n// \t\t\treturn (NULL);\n// \t\tstring = ft_dup_env_value(var_name, shell);\n// \t\tif (!string)\n// \t\t\tstring = ft_strdup(\"\");\n// \t\tfree(var_name);\n// \t\treturn (string);\n// \t}\n// \t// When $ is not followed by valid variable char, treat as literal $\n// \treturn (ft_strdup(\"$\"));\n// }\nchar *ft_getenv(t_shell *shell, const char *varname)\n{\n    t_env_var *env;\n\n    if (!shell || !varname)\n        return NULL;\n\n    env = shell->env_list;\n    while (env)\n    {\n        if (ft_strcmp(env->envar_name, varname) == 0)\n            return env->envar_value; // return pointer to value\n        env = env->next_envar;\n    }\n    return NULL; // not found\n}\n\nchar *ft_process_dollar(const char *str, size_t *i, t_shell *shell)\n{\n    char varname[256];\n    size_t j = 0;\n    char *value;\n\n    if (str[*i] == '?') // special case: last status code\n    {\n        (*i)++;\n        return ft_itoa(shell->last_status);\n    }\n    if (str[*i] == '$') // special case: PID\n    {\n        (*i)++;\n        return ft_itoa(getpid());\n    }\n    if (str[*i] == '{') // ${VAR} syntax\n    {\n        (*i)++; // skip '{'\n        while (str[*i] && str[*i] != '}' && j < sizeof(varname) - 1)\n            varname[j++] = str[(*i)++];\n        if (str[*i] == '}')\n            (*i)++; // skip '}'\n        varname[j] = '\\0';\n    }\n    else\n    {\n        // Normal variable name [A-Za-z_][A-Za-z0-9_]*\n        if (!ft_isalpha(str[*i]) && str[*i] != '_')\n            return ft_strdup(\"$\"); // \"$x\" invalid start → keep '$'\n        while ((ft_isalnum(str[*i]) || str[*i] == '_') && j < sizeof(varname) - 1)\n            varname[j++] = str[(*i)++];\n        varname[j] = '\\0';\n    }\n\n    // Lookup variable in env\n    value = ft_getenv(shell, varname);\n    if (!value)\n        return ft_strdup(\"\"); // undefined → empty\n    return ft_strdup(value);\n}\n\nchar *ft_expand_tilde(const char *str, size_t *i, t_shell *shell)\n{\n    char *home;\n    \n    (void)shell;\n    if (str[*i] == '~')\n    {\n        (*i)++;\n        home = getenv(\"HOME\");\n        if (home)\n            return ft_strdup(home);\n        else\n            return ft_strdup(\"~\");\n    }\n    return ft_strdup(\"~\");\n}\n\nchar *ft_create_expansion_main(const char *input, t_token *token, t_shell *shell)\n{\n    size_t i;\n    char *expand_string;\n    char *piece;\n\n\t(void)input; // input is unused now, but kept for compatibility\n    // SINGLE-quoted: return literal content without outer quotes\n    if (token && token->quote == SINGLE)\n        return ft_strdup(token->token_value);\n\n    // DOUBLE-quoted or unquoted: expand $ and ~\n    expand_string = ft_strdup(\"\");\n    if (!expand_string)\n        return NULL;\n\n    i = 0;\n    // Handle tilde expansion at the beginning\n    if (token->token_value[0] == '~' && (token->token_value[1] == '\\0' || token->token_value[1] == '/'))\n    {\n        piece = ft_expand_tilde(token->token_value, &i, shell);\n        if (!piece || !ft_append_piece(&expand_string, piece))\n            return NULL;\n    }\n    \n    while (token->token_value[i])\n    {\n        if (token->token_value[i] == '$')\n        {\n            i++;\n            piece = ft_process_dollar(token->token_value, &i, shell);\n            if (!piece || !ft_append_piece(&expand_string, piece))\n                return NULL;\n        }\n        else if (token->token_value[i] == '\\\\' && token->token_value[i + 1])\n        {\n            i++; // skip backslash\n            if (token->quote == DOUBLE)\n            {\n                // Handle escape sequences in double quotes\n                if (token->token_value[i] == '$' || token->token_value[i] == '\"' || \n                    token->token_value[i] == '\\\\' || token->token_value[i] == '\\n')\n                {\n                    piece = ft_char_to_str(token->token_value[i]);\n                }\n                else\n                {\n                    // Keep both backslash and character for other escapes\n                    char temp[3] = {'\\\\', token->token_value[i], '\\0'};\n                    piece = ft_strdup(temp);\n                }\n            }\n            else\n            {\n                // In unquoted context, backslash escapes the next character\n                piece = ft_char_to_str(token->token_value[i]);\n            }\n            if (!piece || !ft_append_piece(&expand_string, piece))\n                return NULL;\n            i++;\n        }\n        else\n        {\n            piece = ft_char_to_str(token->token_value[i]);\n            if (!piece || !ft_append_piece(&expand_string, piece))\n                return NULL;\n            i++;\n        }\n\t\t//i++;\n    }\n\n    return expand_string;\n}\n\n\n\n\n\n\n\n// char\t*ft_create_expansion_main(const char *input, t_shell *shell)\n// {\n//     size_t\ti;\n//     char\t*expand_string;\n//     char\t*piece;\n//     int\t\tin_single;\n//     int\t\tin_double;\n\n//     /* If the whole token was single-quoted, everything is literal:\n//      * lexer/parser should have set shell->cmd_list->quote for this arg.\n//      * In that case return a strdup of the input (no expansion). */\n\n//     in_single = 0;\n//     in_double = 0;\n//     if (shell && shell->cmd_list && shell->cmd_list->quote == DOUBLE)\n//         in_double = 1;\n//     if (shell && shell->cmd_list && shell->cmd_list->quote == SINGLE)\n//     {\n//         return (ft_strdup(input));\n//         in_single = 1;\n//     }\n\n//     expand_string = ft_strdup(\"\");\n//     if (!expand_string)\n//         return (NULL);\n//     i = 0;\n//     while (input[i])\n//     {\n//         if (input[i] == '\\'')\n//         {\n//             if (!in_double)\n//                 in_single = !in_single;\n//             else\n//             {\n//                 if (!ft_append_char_to_expand(&expand_string, '\\''))\n//                     return (NULL);\n//             }\n//             i++;\n//         }\n//         else if (input[i] == '\"')\n//         {\n//             if (!in_single)\n//                 in_double = !in_double;\n//             else\n//             {\n//                 if (!ft_append_char_to_expand(&expand_string, '\"'))\n//                     return (NULL);\n//             }\n//             i++;\n//         }\n//         else if (input[i] == '$' && !in_single)\n//         {\n//             i++;\n//             piece = ft_process_dollar(input, &i, shell);\n//             if (!ft_append_piece(&expand_string, piece))\n//                 return (NULL);\n//         }\n//         else\n//         {\n//             piece = ft_char_to_str(input[i++]);\n//             if (!ft_append_piece(&expand_string, piece))\n//                 return (NULL);\n//         }\n//     }\n//     return (expand_string);\n// }\n// ...existing code...\n// ...existing code...\n// ...existing code...\n\n// ...existing code...\nstatic void\tremove_empty_arguments(char **av_cmd)\n{\n    int i, j;\n    \n    if (!av_cmd)\n        return;\n        \n    i = 0;\n    while (av_cmd[i])\n    {\n        if (ft_strlen(av_cmd[i]) == 0)\n        {\n            // Remove this empty argument\n            free(av_cmd[i]);\n            j = i;\n            while (av_cmd[j + 1])\n            {\n                av_cmd[j] = av_cmd[j + 1];\n                j++;\n            }\n            av_cmd[j] = NULL;\n            // Don't increment i since we're now at a new argument\n            continue;\n        }\n        i++;\n    }\n}\n\nvoid\tft_expand_cmds(t_comnd *cmds, t_shell *shell)\n{\n    char\t*expanded;\n\tt_token *tok;\n    t_comnd *saved_shell_cmds;\n    int i;\n\n    /* preserve original shell->cmd_list pointer and restore later */\n    saved_shell_cmds = shell->cmd_list;\n\n    while (cmds)\n    {\n        shell->cmd_list = cmds; // if needed by ft_process_dollar, etc.\n        tok = cmds->av_cmd_lst;\n        i = 0;\n\n        while (tok && cmds->av_cmd[i])\n        {\n            expanded = ft_create_expansion_main(cmds->av_cmd[i], tok, shell);\n\n            if (expanded)\n            {\n                free(cmds->av_cmd[i]);\n                cmds->av_cmd[i] = expanded;\n            }\n\n            i++;\n            tok = tok->next_token;\n        }\n\n        remove_empty_arguments(cmds->av_cmd); // optional cleanup\n        cmds = cmds->next;\n    }\n\n    /* restore original pointer */\n    shell->cmd_list = saved_shell_cmds;\n}\n\n\n// void\tft_expand_cmds(t_comnd *cmds, t_shell *shell)\n// {\n// \tchar\t*expanded;\n// \tint\t\ti;\n\n// \twhile (cmds)\n// \t{\n// \t\ti = 0;\n// \t\twhile (cmds->av_cmd && cmds->av_cmd[i])\n// \t\t{\n// \t\t\texpanded = ft_create_expansion_main(cmds->av_cmd[i], shell);\n// \t\t\tif (expanded)\n// \t\t\t{\n// \t\t\t\tfree(cmds->av_cmd[i]);\n// \t\t\t\tcmds->av_cmd[i] = expanded;\n// \t\t\t}\n// \t\t\ti++;\n// \t\t}\n// \t\tcmds = cmds->next;\n// \t}\n// }\n","size_bytes":10842},".ccls-cache/@home@runner@workspace/SOURCE@lexer@lexer.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   lexer.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/29 19:07:52 by robello           #+#    #+#             */\n/*   Updated: 2025/09/15 13:16:11 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nstatic int\tis_potential_array_assignment(const char *input_line, int start_pos)\n{\n\tint\ti;\n\n\ti = start_pos;\n\t// Look for pattern: IDENTIFIER=( but reject IDENTIFIER=((\n\twhile (input_line[i] && (ft_isalnum(input_line[i]) || input_line[i] == '_'))\n\t\ti++;\n\tif (input_line[i] != '=')\n\t\treturn (0);\n\ti++;\n\tif (input_line[i] != '(')\n\t\treturn (0);\n\t// Reject double parentheses - this should be a syntax error\n\tif (input_line[i + 1] == '(')\n\t\treturn (0);\n\treturn (1);\n}\n\nt_token\t*lex_word(const char *input_line, int *input_ptr)\n{\n\tt_token\t*token;\n\tchar\t*value;\n\tint\t\tstart;\n\tint\t\tparen_depth;\n\tint\t\tis_array_assignment;\n\n\tparen_depth = 0;\n\tstart = *input_ptr;\n\tis_array_assignment = is_potential_array_assignment(input_line, start);\n\tif (is_array_assignment)\n\t{\n\t\t// For array assignments,\n\t\t\t//include parentheses and spaces in the word token\n\t\twhile (input_line[*input_ptr])\n\t\t{\n\t\t\tif (input_line[*input_ptr] == '(')\n\t\t\t\tparen_depth++;\n\t\t\telse if (input_line[*input_ptr] == ')')\n\t\t\t{\n\t\t\t\tparen_depth--;\n\t\t\t\t(*input_ptr)++;\n\t\t\t\tif (paren_depth == 0)\n\t\t\t\t\tbreak ;\n\t\t\t\tcontinue ;\n\t\t\t}\n\t\t\t// Allow spaces inside parentheses for array assignments\n\t\t\telse if (ft_is_space(input_line[*input_ptr]) && paren_depth == 0)\n\t\t\t\tbreak ;\n\t\t\t(*input_ptr)++;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Normal word parsing with backslash escape handling\n\t\twhile (ft_is_word_char(input_line[*input_ptr])\n\t\t\t|| input_line[*input_ptr] == '\\\\')\n\t\t{\n\t\t\tif (input_line[*input_ptr] == '\\\\' && input_line[*input_ptr + 1])\n\t\t\t\t(*input_ptr) += 2; // Skip escaped character\n\t\t\telse\n\t\t\t\t(*input_ptr)++;\n\t\t}\n\t}\n\tvalue = ft_substr(input_line, start, *input_ptr - start);\n\tif (!value)\n\t\treturn (NULL);\n\ttoken = ft_new_token(TOKEN_WORD, value, 0);\n\tif (!token)\n\t\tfree(value);\n\treturn (token);\n}\n\nt_token\t*get_next_token(const char *input_line, int *input_ptr)\n{\n\tchar\tx;\n\n\twhile (ft_is_space(input_line[*input_ptr]))\n\t\t(*input_ptr)++;\n\tif (input_line[*input_ptr] == '\\0')\n\t\treturn (NULL);\n\tx = input_line[*input_ptr];\n\tif (ft_is_single_quote(x))\n\t\treturn (lex_single_quote(input_line, input_ptr));\n\tif (ft_is_double_quote(x))\n\t\treturn (lex_double_quote(input_line, input_ptr));\n\tif (ft_is_metacharacter(x))\n\t\treturn (lex_metacharacter(input_line, input_ptr));\n\treturn (lex_word(input_line, input_ptr));\n}\n\n// Helper function to get next token without skipping initial spaces\nstatic t_token\t*get_next_token_preserve_space(const char *input_line,\n\t\tint *input_ptr, int *had_space)\n{\n\tchar\tx;\n\n\t*had_space = 0;\n\twhile (ft_is_space(input_line[*input_ptr]))\n\t{\n\t\t*had_space = 1;\n\t\t(*input_ptr)++;\n\t}\n\tif (input_line[*input_ptr] == '\\0')\n\t\treturn (NULL);\n\tx = input_line[*input_ptr];\n\tif (ft_is_single_quote(x))\n\t\treturn (lex_single_quote(input_line, input_ptr));\n\tif (ft_is_double_quote(x))\n\t\treturn (lex_double_quote(input_line, input_ptr));\n\tif (ft_is_metacharacter(x))\n\t\treturn (lex_metacharacter(input_line, input_ptr));\n\treturn (lex_word(input_line, input_ptr));\n}\n\n// Helper function to concatenate two token values\nstatic char\t*concat_token_values(const char *val1, const char *val2)\n{\n\tchar\t*result;\n\n\tsize_t len1, len2;\n\tif (!val1)\n\t\tval1 = \"\";\n\tif (!val2)\n\t\tval2 = \"\";\n\tlen1 = ft_strlen(val1);\n\tlen2 = ft_strlen(val2);\n\tresult = malloc(len1 + len2 + 1);\n\tif (!result)\n\t\treturn (NULL);\n\tft_strlcpy(result, val1, len1 + 1);\n\tft_strlcat(result, val2, len1 + len2 + 1);\n\treturn (result);\n}\n\nt_token\t*ft_lexer_main(char *input_line)\n{\n\tint\t\tinput_ptr;\n\tt_token\t*first;\n\tt_token\t*last;\n\tt_token\t*token;\n\tint\t\thad_space;\n\tchar\t*new_value;\n\t// int\t\tprev_quote;\n\t// int\t\tcurr_quote;\n\n\tinput_ptr = 0;\n\tfirst = NULL;\n\tlast = NULL;\n\tif (!input_line || !*input_line)\n\t\treturn (NULL);\n\twhile (input_line[input_ptr])\n\t{\n\t\ttoken = get_next_token_preserve_space(input_line, &input_ptr,\n\t\t\t\t&had_space);\n\t\tif (!token)\n\t\t{\n\t\t\tfree_tokens(first);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\t// Check if we can concatenate with previous token\n\t\tif (!had_space && last && last->type == TOKEN_WORD\n\t\t\t&& token->type == TOKEN_WORD ) //&& last->quote == token->quote)\n\t\t{\n\t\t\t// Concatenate with previous token\n\t\t\tnew_value = concat_token_values(last->token_value,\n\t\t\t\t\ttoken->token_value);\n\t\t\tif (!new_value)\n\t\t\t{\n\t\t\t\tfree_tokens(first);\n\t\t\t\tfree(token->token_value);//added\n\t\t\t\tfree(token); //added\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tif (last->quote == SINGLE || token->quote == SINGLE)\n\t\t\t\tlast->quote = SINGLE;\n\t\t\telse if (last->quote == DOUBLE || token->quote == DOUBLE)\n\t\t\t\tlast->quote = DOUBLE;\n\t\t\telse\n\t\t\t\tlast->quote = NA;\n\n\t\t\tfree(last->token_value);\n\t\t\tlast->token_value = new_value;\n\t\t\t\n\t\t\t// Free the current token since we merged it\n\t\t\tfree(token->token_value);\n\t\t\tfree(token);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Add as new token\n\t\t\tif (!first)\n\t\t\t\tfirst = token;\n\t\t\telse\n\t\t\t\tlast->next_token = token;\n\t\t\tlast = token;\n\t\t}\n\t}\n\treturn (first);\n}\n\n// t_token\t*ft_lexer_main(const char *input_line)\n// {\n// \tint\t\tinput_ptr;\n// \tt_token\t*first;\n// \tt_token\t*last;\n// \tt_token\t*token;\n// \tint\t\thad_space;\n// \tchar\t*new_value;\n\t\n// \tinput_ptr = 0;\n// \tfirst = NULL;\n// \tlast = NULL;\n\t\n// \tif (!input_line || !*input_line)\n// \t\treturn (NULL);\n\n// \twhile (input_line[input_ptr])\n// \t{\n// \t\ttoken = get_next_token_preserve_space(input_line, &input_ptr, &had_space);\n// \t\tif (!token)\n// \t\t{\n// \t\t\tfree_tokens(first);\n// \t\t\treturn (NULL);\n// \t\t}\n\t\t\n// \t\t// Check if we can concatenate with previous token\n// \t\tif (!had_space && last && last->type == TOKEN_WORD && token->type == TOKEN_WORD)\n// \t\t{\n// \t\t\t// Concatenate with previous token\n// \t\t\tnew_value = concat_token_values(last->token_value, token->token_value);\n// \t\t\tif (!new_value)\n// \t\t\t{\n// \t\t\t\tfree_tokens(first);\n// \t\t\t\treturn (NULL);\n// \t\t\t}\n// \t\t\tfree(last->token_value);\n// \t\t\tlast->token_value = new_value;\n// \t\t\t// Free the current token since we merged it\n// \t\t\tfree(token->token_value);\n// \t\t\tfree(token);\n// \t\t}\n// \t\telse\n// \t\t{\n// \t\t\t// Add as new token\n// \t\t\tif (!first)\n// \t\t\t\tfirst = token;\n// \t\t\telse\n// \t\t\t\tlast->next_token = token;\n// \t\t\tlast = token;\n// \t\t}\n// \t}\n// \treturn (first);\n// }\n","size_bytes":6873},".ccls-cache/@home@runner@workspace/SOURCE@lexer@lexer_utils.c":{"content":"/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   lexer_utils.c                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/20 14:01:05 by gkamanur          #+#    #+#             */\n/*   Updated: 2025/08/25 14:48:30 by gkamanur         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/minishell.h\"\n\nint\tft_is_space(char x)\n{\n\tif (x == ' ' || x == '\\t')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_is_single_quote(char x)\n{\n\tif (x == '\\'')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_is_double_quote(char x)\n{\n\tif (x == '\"')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_is_quote(char x)\n{\n\tif (ft_is_single_quote(x) || ft_is_double_quote(x))\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_is_redirect_char(char x)\n{\n\tif (x == '<' || x == '>')\n\t\treturn (1);\n\treturn (0);\n}\n","size_bytes":1367}},"version":1}